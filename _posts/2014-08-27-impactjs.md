---
layout: post
title: ImpactJS Tutorial
tags: [Tutorial]
image:
  feature: triangle.svg
  background: tweed.png
---

Over the past 2 years I have worked on developing games in my spare time using various JavaScript and Python frameworks. Of these frameworks, my favorite has been <a href="http://impactjs.com/">ImpactJS</a>. As such, this post serves as an in-depth tutorial for anyone wanting to get started with developing games using ImpactJS. 


#### Personal experience

Throughout Spring 2013 - Fall 2014, I have taken part in <a href="http://jeremyneiman.com/zombie/">building</a> <a href="http://drksephy.bitbucket.org/" >three </a> <a href="http://drksephy.github.io//fireemblem/" >games</a> using the ImpactJS Game Engine within the City College of New York (CCNY) Game development club. 

As the Game Development club begins to meet in Fall 2014, I will be giving a presentation at CCNY on getting started with JavaScript and developing simple Platforming games using ImpactJS. This tutorial is meant to supplement my presentation and to give students a guide to refer to when developing their own games, but it is intended for all audiences. 

#### What we will cover

This tutorial will cover the following topics:

* Why use ImpactJS?
* Project Structure
* Understanding ImpactJS game loop
* Game logic implementation
* Player / enemy implementation
* Creating a simple powerup
* Creating levels 

Throughout the lifetime of this tutorial, it will be updated with extending new features. 

#### Why ImpactJS?

At the start of the Game Development club in Spring 2013, our group was experimenting with several game engines at the time. After spending a few weeks trying out various frameworks and building simple games, we realized how much functionality would have to be built just to create a simple, complete game. These features revolved around player physics, camera options, enemies/artificial intelligence, level transitioning, level building and collision. At that time, building our own game framework was not an option - which is when we stumbled upon ImpactJS. 

ImpactJS provides all of the features noted above and more, exposing easy methods for creating entities (players, enemies), level transitioning, camera functionalities and collision. To top it all off, ImpactJS comes with its own Tile Editor - Weltmeister. Weltmeister provides an easy to use interface for loading level assets, adding/removing layers, setting up collisions, and exporting the level for use within ImpactJS itself. At the moment, ImpactJS costs a hefty $99, but if you can get over the cost then you've got your hands on a very powerful game engine. 

#### Skills / Pre-requisites 

To get the most of this tutorial, you should have some understanding of the following:

* Basic knowledge of JavaScript (Types, pointers, scope)
* Basic usage of your terminal (Navigating directories, creating folders and files)
* Github account (for cloning the completed project repository)

Knowledge of using your terminal is not required (as you can create files manually), but it is recommended to learn. Throughout this tutorial, I will often use bash commands native to UNIX systems (Mac OS X, Linux). I have provided some useful resources for learning below.


<i class="fa fa-files-o"></i> <a href="http://www.ee.surrey.ac.uk/Teaching/Unix/">Unix Tutorial Home</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i class="fa fa-files-o"></i> <a href="http://www.ee.surrey.ac.uk/Teaching/Unix/unix1.html">Unix Tutorial Part 1</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-files-o"></i> <a href="http://www.ee.surrey.ac.uk/Teaching/Unix/unix2.html">Unix Tutorial Part 2</a>

<br>

I also recommend you find a good text editor and get used to it. My personal favorites are [Vim](http://www.openvim.com/tutorial.html) and [Sublime Text](http://www.sublimetext.com/).

#### Debugging

In order to properly debug JavaScript, we need the right tools. Luckily, Chrome provides `Developer Tools` for interacting with the DOM and for debugging JavaScript code. For Firefox users, there is an extension called `Firebug` which provides the same functionality. I recommend you become familiar with either of these tools, as they are essential for debugging any JavaScript code you will write in the future. See the links below for downloads and tutorials. 

<i class="fa fa-files-o"></i> <a href="https://addons.mozilla.org/en-US/firefox/addon/firebug/">Firebug download</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-files-o"></i> <a href="http://getfirebug.com/whatisfirebug">Firebug tutorial</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-files-o"></i> <a href="https://developer.chrome.com/devtools">Developer tools tutorial</a>

<br>

#### Project Structure

At the end of this tutorial, your project structure should look like the following: 

{% highlight bash %}

├── index.html                  # Serves game files. Included with ImpactJS 
├── lib                         
│   ├── game 
│   │   ├── entities            # Place all game entities in here 
│   │   │   ├── goomba.js
│   │   │   ├── mushroom.js
│   │   │   └── player.js
│   │   ├── levels              # Place all game levels in here
│   │   │   └── basic.js
│   │   └── main.js
│   ├── impact                  # ImpactJS source code, included with ImpactJS
│   │   ├── animation.js
│   │   ├── background-map.js
│   │   ├── collision-map.js
│   │   ├── debug
│   │   │   ├── debug.css
│   │   │   ├── debug.js
│   │   │   ├── entities-panel.js
│   │   │   ├── graph-panel.js
│   │   │   ├── maps-panel.js
│   │   │   └── menu.js
│   │   ├── entity.js
│   │   ├── font.js
│   │   ├── game.js
│   │   ├── image.js
│   │   ├── impact.js
│   │   ├── input.js
│   │   ├── loader.js
│   │   ├── map.js
│   │   ├── sound.js
│   │   ├── system.js
│   │   └── timer.js
│   └── weltmeister             # Weltmeister source code, included with ImpactJS
│       ├── api
│       │   ├── browse.php
│       │   ├── config.php
│       │   ├── glob.php
│       │   └── save.php
│       ├── arrow.png
│       ├── collisiontiles-64.png
│       ├── config.js
│       ├── edit-entities.js
│       ├── edit-map.js
│       ├── entities.js
│       ├── evented-input.js
│       ├── jquery-1.7.1.min.js
│       ├── jquery-ui-1.8.1.custom.min.js
│       ├── modal-dialogs.js
│       ├── select-file-dropdown.js
│       ├── tile-select.js
│       ├── undo.js
│       ├── weltmeister.css
│       └── weltmeister.js
├── media                       # Place all game media here
│   ├── 04b03.font.png
│   ├── bg
│   │   └── star.png
│   ├── enemies
│   │   └── goomba.png
│   ├── fg
│   │   └── forest.png
│   ├── mushroom.png
│   └── player.png
├── server.py                   # Python web server for ImpactJS. Download separately.
└── weltmeister.html            # Weltmeister page, included with ImpactJS.

{% endhighlight %}

Please note that the following files are provided for you upon downloading ImpactJS: `weltmeister.html`, `index.html`, `impact folder`, `weltmeister folder`. 

<i class="fa fa-files-o"></i> <a href="https://github.com/DrkSephy/ACM-Game-Presentation">Download completed tutorial source code</a>

<br>

#### Directory setup


First, we create a root folder for our project and other necessary folders. 

{% highlight bash %}

$ mkdir tutorial
$ cd tutorial
~/tutorial $ mkdir lib
~/tutorial $ mkdir media
~/tutorial $ mkdir lib/game
~/tutorial $ mkdir lib/game/entities
~/tutorial $ mkdir lib/game/levels

{% endhighlight %}

Within the root folder `tutorial`, place `weltmeister.html` (received from purchasing ImpactJS), `server.py` (obtained from <a style="color:blue" href="https://github.com/amadeus/python-impact" > here </a>), and `index.html` (also received from purchasing ImpactJS). Within `tutorial/lib`, place the `impact` and `weltmeister` folders. Lastly, you may obtain all of the media for this project <a style="color:blue" href="https://github.com/DrkSephy/ACM-Game-Presentation" > here </a>. 

ImpactJS will look for two things when loading a game: a `main.js` file within `lib/game` and `impact.js` inside `lib/impact`. These are referenced within `index.html`, which is the file that gets served by our web server, `server.py`. These directories can be changed as needed, so long as the updated changes are reflected within `index.html`.

#### Running the game / Using Weltmeister

In order to run an ImpactJS game or access the tile editor, Weltmeister, you will need a web server to serve `index.html`. For this, we can run `server.py` which will provide us with two links: `http://localhost:8080` for accessing the game, and `http://localhost:8080/editor` for accessing Weltmeister. The screenshot below shows the output of running `server.py`: 

![server.py]({{ site.url }}/img/terminal.png)

#### Understanding ImpactJS game loop

With all of our directories in place, we move onto building our main game file, `main.js`. 

{% highlight bash %}

~/tutorial $ cd lib/game
~/tutorial/lib/game $ vim main.js 

{% endhighlight %}

Within `main.js`, we require any modules needed in the game (all entities, levels and plugins), set up key bindings, camera settings, draw to the screen, and initialize our game instance. We begin by declaring our module and setting up our basic game instance. 

{% highlight javascript %}

ig.module(
    'game.main'
)
.requires(
    'impact.game',
    'impact.debug.debug',
    'game.levels.basic'
)

.defines(function(){
    MyGame = ig.Game.extend({
        init: function(){
            this.loadLevel(LevelBasic);
        }
        
    });

    ig.main('#canvas', MyGame, 60, 320, 240, 2);
});

{% endhighlight %}

By running `server.py` and navigating to `http://localhost:8080`, you should see the level displayed.

[ Insert 1.png here ]

Having a plain level with no player is no fun, right? Let's start implementing our player.

{% highlight javascript %}

ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        animSheet: new ig.AnimationSheet('media/player.png', 16, 28),
        size: {x: 16, y: 28},
        flip: true,

        init: function(x, y, settings){
            this.parent(x, y, settings);
            this.addAnim('idle', 1, [1]);
        },

    });
});

{% endhighlight %}

Here we only create our player module, define an animation sheet and just a single animation (idle). Navigate to `http://localhost:8080/editor` and drop
in our Player Entity, then navigate to the game page. We can see our Player Entity!

[ Insert 2.png here ]

Our Player isn't very interesting right now, as he only has one animation. Let's go ahead and add in animations for running, jumping and falling:

{% highlight javascript %}
    init: function(x, y, settings){
        [ ...previous code ...]
        this.addAnim('run', 0.10, [1, 0]);
        this.addAnim('jump', 1, [2]);
        this.addAnim('fall', 0.4, [2]);
    }

{% endhighlight %}

On its own, the above code does not change anything - we cannot interact with our player. We must bind keys to move our player, which we can easily do inside of our `init` function within `main.js`. 

{% highlight javascript %}
ig.module(
    'game.main'
)
.requires(
    'impact.game',
    'impact.debug.debug',
    'game.levels.basic'
)

.defines(function(){
    MyGame = ig.Game.extend({
        init: function(){
            // Define our key bindings here
            ig.input.bind(ig.KEY.LEFT_ARROW, 'left');
            ig.input.bind(ig.KEY.RIGHT_ARROW, 'right');
            ig.input.bind(ig.KEY.X, 'jump');
            this.loadLevel(LevelBasic);
        }
        
    });

    ig.main('#canvas', MyGame, 60, 320, 240, 2);
});

{% endhighlight %}

If we navigate to the game, we see the same thing. We still cannot move our player, despite pressing our keys which bind to movement. The reason for this is that we must write our logic for moving the player when certain keys are pressed. Since we know the `update` method runs once per frame, this is the place where we define how our player entity behaves - whenever a key press occurs, our player will respond based on the logic we implement for each movement key.

{% highlight javascript %}

ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        [ ... animation setup... ]
        
        // Add values for ground and air acceleration
        accelGround: 200,
        accelAir: 310,

        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            // Add left/right movement logic
            var accel = this.standing ? this.accelGround : this.accelAir;
            if(ig.input.state('left')){
                this.accel.x = -accel;
                this.flip = false;
            } else if(ig.input.state('right')){
                this.accel.x = accel;
                this.flip = true;
            } else
                this.accel.x = 0;

            
            this.parent();
            
        },

    });
});

{% endhighlight %}

Navigate to the game and try to move the Player left and right. Success...?

[ Insert 3.png ]

Our Player just slides around, left to right. He doesn't animate to the left/right based on keypress. This is a simple fix, by simply adding this line:

{% highlight javascript %}

ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        [ ... animation setup... ]
        
        // Add values for ground and air acceleration
        accelGround: 200,
        accelAir: 310,

        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            [ ... ]

            this.currentAnim.flip.x = this.flip;
            this.parent();
            
        },

    });
});

{% endhighlight %}

Our Player will still slide around in midair, but he will properly animate and respond to left/right key movement. Speaking of sliding around in midair, we can fix this by adding attaching the `gravity` property to the game. Let's go ahead and do that:

{% highlight javascript %}

ig.module(
    'game.main'
)
.requires(
    'impact.game',
    'impact.debug.debug',
    'game.levels.basic'
)

.defines(function(){
    MyGame = ig.Game.extend({

        // Add gravity 
        gravity: 300,
        init: function(){
            [ ... ]
        }
        
    });

    ig.main('#canvas', MyGame, 60, 320, 240, 2);
});

{% endhighlight %}

Our Player now obeys the laws of gravity and moves along the floor now.

[ Insert 4.png ]

After moving to the right, we notice we are stuck in the pit and cannot get out. Now is a good time to implement the `jump` ability. 

{% highlight javascript %}
ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        [ ... ]
        // How high the Player can jump
        jump: 360,
        

        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            [ ... ]

            // Jumping logic: CASE 1
            if(this.standing && ig.input.state('jump')){
                if(this.vel.y == 0){
                    this.vel.y = -this.jump;
                    this.falling = false;
                }
            }

            this.currentAnim.flip.x = this.flip;
            this.parent();
            

        },

    });
});
{% endhighlight %}

[ Insert 5.png here ]

If the `jump` button is pressed and the player is standing (has not jumped yet), we invert the Player's `y-velocity` based on their jump factor. By making this value higher/lower, we can effectively control how high our Player can jump. What do we do when the Player is falling though? We should also handle this case as well.

{% highlight javascript %}
ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        animSheet: new ig.AnimationSheet('media/player.png', 16, 28),
        size: {x: 16, y: 28},
        flip: true,
        accelGround: 200,
        accelAir: 310,
        jump: 360,


        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            [ ... ]

            // Jumping logic: CASE 2
            else if(!this.standing && !ig.input.state('jump') && !this.falling){
                this.vel.y = Math.floor(this.vel.y/3);
                this.falling = true;
            }

            this.currentAnim.flip.x = this.flip;

            this.parent();
            

        },

    });
});
{% endhighlight %}

Our Player will not animate any different from before because we haven't actually written any logic to determine which animation should be playing based on all key inputs. To handle this, observe the changes below:

{% highlight javascript %}
ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        [ ... ]


        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            [ ... ]

            this.currentAnim.flip.x = this.flip;

            this.parent();
            
            // Based on velocity and standing/falling, 
            // display the right animation
            if(this.vel.y < 0 && !this.standing)
                this.currentAnim = this.anims.jump;
            else if(this.vel.y > 0 && !this.standing)
                this.currentAnim = this.anims.fall;
            else if(this.vel.x != 0)
                this.currentAnim = this.anims.run;
            else
                this.currentAnim = this.anims.idle;

        },

    });
});
{% endhighlight %}

Using the Player's `velocity` and `.standing` property, we can determine what animation should be displaying based on key press. Our Player finally moves and animates correctly! He's still sliding all over the place though, as if unaffected by friction. Luckily, we can easily fix this by using the `friction` property belonging to any Entity to control how our Player is affected. 

{% highlight javascript %}
ig.module(
    'game.entities.player'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityPlayer = ig.Entity.extend({
        [ ... ]
        // Apply friction and maxVel to make movement more fluid
        friction: {x: 500, y: 0},
        maxVel: {x: 100, y: 160},


        init: function(x, y, settings){
            [ ... ]
        },

        update: function(){
            [ ... ]
        },

    });
});
{% endhighlight %}

By capping the Player's `maxVel` value and applying `friction`, we now move properly without sliding all over the stage. With this last step, we have fully implemented our Player entity.



<i class="fa fa-files-o"></i> <a href="http://impactjs.com/documentation/class-reference/entity#collides">Read Entity Documentation</a>




<i class="fa fa-files-o"></i> <a href="http://impactjs.com/documentation/class-reference/entity#addanim">Read Animation Documentation</a>


{% highlight bash %}
~/tutorial/lib/game/entities $ vim goomba.js
{% endhighlight %}

For reference, the completed `goomba.js` file is shown below. 

{% highlight javascript %}

ig.module(
    'game.entities.goomba'
)
.requires(
    'impact.entity',
    'game.entities.player'
)

.defines(function(){
    EntityGoomba = ig.Entity.extend({
        type: ig.Entity.TYPE.B, 
        checkAgainst: ig.Entity.TYPE.A,
        collides: ig.Entity.COLLIDES.PASSIVE, 

        animSheet: new ig.AnimationSheet('media/enemies/goomba.png', 25, 26),
        size: {x: 22, y: 19},
        maxVel: {x: 500, y: 100},
        flip: true,
        friction: {x: 1, y: 0},
        speed: 50,

        init: function(x, y, settings){
            this.parent(x, y, settings);
            this.addAnim('crawl', 0.20, [0, 1]);
            this.offset.x = 1;
        },

        update: function(){
            // Determine which direction we are moving in
            var xdir = this.flip ? -1: 1;
            this.vel.x = this.speed * xdir;
            this.parent();
        },

        handleMovementTrace: function(res){
            this.parent(res);
            // If this entity collides with the collision map,
            // flip the animation. 
            if(res.collision.x){
                console.log(this.flip);
                this.flip = !this.flip;
                this.anims.crawl.flip.x = !this.flip;
            }
        },

        collideWith: function(other, axis){
            if(other instanceof EntityPlayer){
                if(axis === 'y'){
                    this.kill();
                }
                else { 
                    other.receiveDamage(1, this);
                }
            }
        },

        check: function(other){
            other.receiveDamage(1, this);
        },

        kill: function(){
            this.parent();
        },

        receiveDamage: function(value){
            this.parent(value);
        },
    });
});

{% endhighlight %}

For the most part, the setup should be the same as `player.js`. There are some methods that are new here, so let's go over those. 

{% highlight javascript %}
handleMovementTrace: function(res){
    this.parent(res);
    // If this entity collides with the collision map,
    // flip the animation. 
    if(res.collision.x){
        console.log(this.flip);
        this.flip = !this.flip;
        this.anims.crawl.flip.x = !this.flip;
    }
},
{% endhighlight %}

`handleMovementTrace` tracks collisions between this entity and the collisonMap, which is the collision layer of the level itself. Based on how it is colliding with the collisionMap, we flip the animation so the entity faces the right direction. 

<i class="fa fa-files-o"></i> <a href="http://impactjs.com/documentation/class-reference/entity#handlemovementtrace">Read handleMovementTrace Documentation</a>

<br>

{% highlight javascript %}

collideWith: function(other, axis){
    if(other instanceof EntityPlayer){
        if(axis === 'y'){
            this.kill();
        }
        else { 
            other.receiveDamage(1, this);
        }
    }
},

{% endhighlight %}

This method should be self-explanatory due to the name, except that it tracks collisions between this entity and other entities. Based on the axis of collision, we determine if we should kill this entity (if collision occured on the y-axis), or damage the opposing entity (collision occured on the x-axis).  

{% highlight javascript %}

check: function(other){
    other.receiveDamage(1, this);
},

{% endhighlight %}

Whenever this entity overlaps with another in the game world, the latter entity is passed as the parameter to `check` and we call Impact's `receiveDamage` method on it to apply damage. 

<i class="fa fa-files-o"></i> <a href="http://impactjs.com/documentation/class-reference/entity#check">Read Check Documentation</a>

<br>

{% highlight javascript %}

kill: function(){
    this.parent();
},

{% endhighlight %}

When an entities `health` property is reduced to 0, we call `ig.Entity` kill method through `this.parent()` to remove it from the game world. `this.parent()` will refer to the object that this entity inherits from, i.e: `ig.Entity` base class which contains the `kill` method. It is important to notice that we never explicity defined a `health` property; this is also inherited from `ig.Entity` base class.

{% highlight javascript %}

receiveDamage: function(value){
    this.parent(value);
},

{% endhighlight %}

As with `kill`, whenever there is a collison between two entities in the game world, we call `this.parent(value)` to call `ig.Entity` receiveDamage method and apply the damage. 

With that, we have now completed both a player and an enemy entity. Before we finish building our game, how about we add a simple powerup entity for our player to collect?

{% highlight bash %}

~/tutorial/lib/game/entities $ mushroom.js

{% endhighlight %}

For the sake of demonstration, the mushroom powerup will increase the player's health by 10 upon collision. The code for the mushroom entity is shown below:

{% highlight javascript %}

ig.module(
    'game.entities.mushroom'
)
.requires(
    'impact.entity'
)
.defines(function(){
    EntityMushroom = ig.Entity.extend({
        size: {x: 16, y: 16},
        maxVel: {x: 100, y: 100},
        speed: 50,
        gravity: 10,
        gravityFactor: 1,
        collides: ig.Entity.COLLIDES.NONE,
        type: ig.Entity.TYPE.B,
        checkAgainst: ig.Entity.TYPE.A,
        animSheet: new ig.AnimationSheet('media/mushroom.png', 16, 16),

        init: function(x, y, settings){
            this.parent(x, y, settings);
            this.addAnim('idle', 1, [0]);
        },

        update: function(){
            var xdir = this.flip ? -1 : 1;
            this.vel.x = this.speed * xdir;
            this.parent();
        },

        handleMovementTrace: function(res){
            this.parent(res);
            if(res.collision.x){
                this.flip = !this.flip;
                this.anims.idle.flip.x = this.flip;
            }
        },

        check: function(other){
            other.receiveDamage(-10, this);
            this.kill();
        },
    });
});

{% endhighlight %}

The implementation should seem very straightforward - most of the code comes directly from `goomba.js`. The only change is within the `check` method, which applies negative damage to the player upon collision, which in turn heals the player since it is doing negative damage. 

Now that we have implemented all of our game entities, all that is left is a level to play. To do so, navigate to the url provided by running `server.py`: `http://localhost:8080/editor` and begin building your level. This tutorial will not cover building levels using Weltmeister, as there are already resources and videos that give great explanations. See below for links to these resources. 

<i class="fa fa-files-o"></i> <a href="http://impactjs.com/documentation/weltmeister">Weltmeister Documentation</a> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i class="fa fa-file-video-o"></i> <a href="http://impactjs.com/documentation/video-tutorial-weltmeister">Watch Video</a>

<br>

If you want to grab a test level, you may do so <a style="color:blue" href="https://github.com/DrkSephy/ACM-Game-Presentation/tree/master/lib/game/levels">here</a> and drop it inside of `lib/game/levels`. With everything in place, run `server.py` and navigate to `http://localhost:8080` to play the game. Before wrapping up, we will look at ImpactJS debug panel. 

#### Debug Panel

When running the game with `impact.debug.debug` required inside `main.js`, you will see a debug panel on the bottom of your game instance. 

![debug]({{ site.url }}/img/debug.png)

Here we can see that the debug panel gives us useful information, such as performance of our game, collision boxes around all entities, and velocity trajectories of all moving entities. We can also see how many draws are being performed on screen, as well as the number of entities in the game world. Alongside our browser developer tools and these analytics, we have a powerful set of tools for debugging our game. 

#### Closing

If you've made it this far, congratulations! You now have a working example of a simple platforming game built with ImpactJS. This tutorial will be updated with more content as times goes on. The topics I would like to cover are: 

* More powerups
* Implementations of different types of enemies
* Creating different game states for Title Screens and Game Over screens

Stay tuned, and thanks for reading. 


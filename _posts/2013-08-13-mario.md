---
layout: portfolio_entry
title: Super Mario World Koopa Krisis
image: /img/koopa-krisis/titlescreen.png
---

Super Mario World - Koopa Krisis is a JavaScript remake of Super Mario World, built on top of the ImpactJS Game Engine, purely for educational purposes. The motivation of this project is to create a browser-only version of one of the most iconic games in the history of Nintendo, and to further my knowledge of JavaScript and the ImpactJS framework.

#### Motivation 

As the new leader of CCNY ACM's Game Development group for the Fall 2013 - Spring 2014 year, I decided to experiment with the ImpactJS Game Engine after being exposed to it in Fall 2012. I decided to begin working on a simple platformer game in late July, which soon turned out to be heavily based on Super Mario World. My motivation was to create a skeleton game which others could build on top of, and to produce a well polished game at the end of the Fall 2013 semester. Once our Game Development club meetings started, I assembled a team of 5 others and development began. 

#### Development Roadmap

My team this semester was very enthusiastic about this game, and so I knew that a detailed listing of all tasks needed to be done. After spending a session explaining the game engine, basic JavaScript and how projects are structured using ImpactJS, my group quickly caught on and started to work on their respective tasks. A list of comprehensive tasks are shown below:

* Artificial Intelligence of Enemies
    * Understanding the ImpactJS Game loop 
    * Graphics for Enemies
* Powerup System
    * Various powerups
    * Powerup transitions when getting hit
* Collectible Items
    * Coins
    * Free lives
* Ability to transition between levels
    * Ability to have different songs per level
* Ability to use pipes to transition to levels
* Sloped tile movement
* Level building
    * Asset gathering

I decided to give each member of my team 1-2 different enemies each week to work on, while providing a skeleton file containing the animation frames already set up, as well as detailed descriptions of enemy behavior coupled with videos of demonstration for those not familiar with Super Mario World. In the meantime, I would work on various systems such as the powerups, collectible items, level building and other things critical to the gameplay itself.

#### Understanding the ImpactJS Game Loop

To discuss creating enemy AI, we must first understand ImpactJS's game loop. Any object that can interact within the game's environment is called an `entity`, and therefore creating new enemies is the same as creating a new entity. Each entity has their own base methods which can be extended. To make our codebase modular, we created a base entity named `basic_ai.js` which contains these methods, allowing us to extend from it and have our new entities inherit the properties from `basic_ai.js` and drastically make our codebase more readable. The following is a listing of the important methods found within our `basic_ai.js` module:

{% highlight javascript linenos %}
    init: function(x, y, settings) {
            // Init method is used for setting up animations
            // and temporary variables
            this.parent(x, y, settings);

            // Set up animations
            /** Animations should be handled by each enemy. **/
            this.healthTimer = new ig.Timer();
            tempHealth = this.health;
            // Load player object if not in Weltmeister
            if(!ig.global.wm)
                my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
        }        
{% endhighlight %}

{% highlight javascript linenos %}
     // handleMovementTrace is mostly for checking collisions
     // against other entities in conjunction with the 
     // `collidesWith method.
     handleMovementTrace: function(res) {
            this.parent(res);

            // If the enemy collides with a wall, make them turn around.
            if(res.collision.x) {
                this.flip = !this.flip;
                this.currentAnim.flip.x = this.flip;
            }
        }, 
    
{% endhighlight%}

{% highlight javascript linenos %}
    // Collisions with player are handled through the following function.
        /** Certain enemies with advanced collisions may wish to override this
            function with their own collision handling code. **/
        collideWith: function(other, axis) {
            // Only do something if colliding with the Player
            if(other instanceof EntityPlayer) {
                // Prevents enemy from being killed from below.
                if(axis == 'y' && this.pos.y > other.pos.y) {
                    other.vel.y = this.damage_jump;
                    this.kill();
                } else {
                    other.receiveDamage(this.collide_damage, this);
                    // Push player back if collides with enemy horizontally.
                    if(other.pos.x > this.pos.x)
                        other.vel.x = this.damage_push;
                    else
                        other.vel.x = -this.damage_push;
                }
                
                // If player's health <= 0 (player dead), re-detect player
                // entity (respawned player).
                if(other.health <= 0)
                    my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
            }
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Simply setting up collisions isn't enough, we must create a method
    // which will check if a collision occurs. This method overrides the
    // .check() function, which gets called when a collision is detected,
    // and applies damage to the entity it collides with.
    check: function(other, axis) {
            if(other instanceof EntityPlayer)
                if(axis == 'x')
                    other.receiveDamage(this.collide_damage, this);
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy's death (and player's rewards from enemy's death) is handled
    // through the following function.
        kill: function() {
            ig.game.stats.kills++;
            ig.game.increaseScore(this.kill_score);
            ig.game.spawnEntity(EntityDeathExplosionParticle, this.pos.x, this.pos.y, {particles:2, colorOffset: 1});
            this.parent();
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy receiving damage is handled through the following function.
        receiveDamage: function(value) {
            this.parent(value);
            this.healthTimer.set(0);
        }
{% endhighlight %}

With these methods written, there only remains two methods needed to implement: `draw()` and `update()`. Both of these methods are called on every frame of the game, and the `update()` method contains the meat of manipulating an entity through various properties. Due to the behavior of the `update()` method, we create methods such as `init()` which will initialize the variables and properties needed by the entity, such as flags denoting when to attack or when to follow a player. 

#### Enemy Artificial Intelligence

Now that we are more familiar with ImpactJS's game loop, we can move on to creating some new enemies. Suppose we want to create a simple entity which will walk from right to left, and if it collides with a wall, it flips and begins to walk in the opposite direction. This is simple enough, as shown in the snippet below of `blue_koopa.js`:

{% highlight javascript linenos %}
/*
    Blue Koopa
    ----------
    AI: Moves left and right, detects ledges.
*/

ig.module('game.entities.enemies.blue_koopa')
.requires('game.entities.ai.basic_ai')

.defines(function() {
    EntityBlue_koopa = EntityBasic_ai.extend({

        // Add animation
        animSheet: new ig.AnimationSheet('media/enemies/koopa_blue.png', 32, 32),
        size: {x: 18, y: 29},
        //flip: false,
        //health: 10,
        collide_damage: 2,
        stomp: new ig.Sound('media/sounds/sfx/smw_stomp.*'),

        // Set up animations
        init: function(x, y, settings) {
            this.parent(x, y, settings);
            this.addAnim('crawl', 0.20, [0,1]);
            this.offset.x = 6;
            this.offset.y = 2;
        },

        update: function() {
            // On collision, a flip property is toggled,
            // allowing movement in the opposite direction
            var xdir = this.flip ? -1 : 1;
            this.vel.x = this.speed * xdir;
            this.parent();
        }
    }); // End EntityBlueKoopa
}); // End .defines

{% endhighlight%}

Even though the enemy above is very simplistic, it follows the main recipe for most enemies in Super Mario World - it moves from right to left, and flips on collision. Building on top of this entity, we can create an entity which follows the player once they are in close proximity to each other. Below is a snippet containing the `update()` method of `flying_yellow_koopa`, which exhibits this behavior: 

{% highlight javascript linenos %}
     update: function() {
            var xdir = this.flip ? 1 : -1;
            this.vel.x = this.speed * xdir;
            this.parent();

            if(my_player != null) {
                var target_x = 0;
                var target_y = 0;
                target_x = my_player.pos.x;
                target_y = my_player.pos.y;
                var stalking = false;

                // Player is within enemy's potential detection range but has not detected player yet
                if(!this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_check_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_check_dist.y) {
                    // Player in enemy's line-of-sight --> Begin stalking behavior
                    if((target_x > this.pos.x && this.flip) || (target_x < this.pos.x && !this.flip))
                        this.stalking = true;
                // Enemy has detected player --> Begin stalking behavior; 
                // Extend detection/stalking range
                } else if(this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_chase_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_chase_dist.y) {
                    // Player is behind enemy --> Enemy faces player
                    if((target_x < this.pos.x && this.flip) || (target_x > this.pos.x && !this.flip)) {
                        this.flip = !this.flip;
                        this.anims.crawl.flip.x = !this.flip;
                    }
                // Player stepped outside of detection distance --> Reset behavior (do not stalk)
                } else
                    this.stalking = false;
            }
        }

{% endhighlight %}

After creating over 20+ enemies, it became clear to my group that creating more advanced entities simply revolves around having more and more properties, with each one acting as flags denoting their behavior at different instances of time based on other conditions. In actuality, this is the power of **Object Oriented Programming**, which gives the advantage of building complex structures while building off objects and the properties/attributes used to describe those objects. Within just a few weeks of development, my group became familiar with the ImpactJS Game Engine and we began to move into more complicated gameplay features. 

#### Level / Music Transitions

Moving on to more aesthetic gameplay features, we decided to tackle the problem of having different songs for each level. ImpactJS has its own `sound` class which can be derived from, unfortunately it has no way of playing different songs for different levels without a hacky solution. Fortunately, we were able to come up with a clever solution involving a plugin created for ImpactJS named `director`, which contains a set of helpful methods for creating an array of levels that can be transitioned through using provided methods. By tailoring this plugin and creating a second array containing our songs, we were able to sync up both our `level array` and `music array` and manipulate the game loop to map each song to each level. The following code snippet shows our solution:

{% highlight javascript linenos %}

    ig.module(
    'plugins.director.director'
    )
    .requires(
        'impact.impact'
    )
    .defines(function(){

    ig.Director = ig.Class.extend({
      //Initialize the class with game representing the main game object
      //and levels being an array of level objects.
      //The first level in the array is loaded by default.
      init: function(theGame, initialLevels, initialSongs, musicDir){
        this.game = theGame;
        this.levels = [];
        this.currentLevel = 0;
        this.append(initialLevels);
        
        musicDir = typeof musicDir !== 'undefined' ? musicDir : "";
        initialSongs = typeof initialSongs !== 'undefined' ? initialSongs : [];
        
        for(var i = 0; i < initialSongs.length; i++){
            ig.music.add(musicDir + initialSongs[i] + '.*', i);
        }
        ig.music.loop = true;
        return this.loadLevel(this.currentLevel);
      },

      loadLevel: function(levelNumber){
        //Load a level by its position in this.levels array
        //and set the this.currentLevel to that position.
        this.currentLevel = levelNumber;

        this.game.loadLevel( this.levels[levelNumber] );
        ig.music.play( levelNumber );
        return true;
      },
      
      append: function(levels){
        //Append a single new level or an array of new levels.
        newLevels = [];
        if (typeof(levels) === 'object'){
          if (levels.constructor === (new Array).constructor){
            newLevels = levels;
          }
          else{
            newLevels[0] = levels;
          }
          this.levels = this.levels.concat(newLevels);
          return true;
        }
        else{
          return false;
        }
      },

      nextLevel: function(){
        //Advance to the next level provided we are not at 
        //the end of the array.
        if (this.currentLevel + 1 < this.levels.length){
          ig.music.next();
          return this.loadLevel(this.currentLevel + 1);
        }
        else{
          return false;
        }
      },
{% endhighlight %}

And here is the change needed within `main.js`:

{% highlight javascript linenos %}
    //LevelIndex:   [0------------, 1------------------, 2---------, 3-------------------, 4---------------------, 5--------------, 6-----------------, 7---------------, 8----------, 9-------------, 10----------------, 11------------, 12-----------, 13------------, 14----------------]
    levelVariables: [LevelTutorial, LevelBest_overworld, LevelSnowy, LevelUndergroundsnow, LevelUndergrounddesert, LevelMainlevel1, LevelOutdoorcastle, LevelForestRuins, LevelDesert,  LevelMountain, LevelMaincastle,    LevelBoss1lair, LevelGauntlet, LevelGauntlet2, LevelFinalgauntlet],
    levelMusic:     ['smw_remix',   'map_theme',         'snowman',  'barrel_volcano',     'ryu',                  'maze',          'snake_man',        'tarm_ruins',     'desert',     'dark_world',  'madness_fortress', 'epic_boss',    'wily_castle', 'wily_castle',  'bowser_battle'],

{% endhighlight %}

After understanding how `director.js` works in conjunction with the ImpactJS game loop, we moved onto something new: transitioning between different levels / different parts within the same level using warp pipes/doors.

#### Transitioning to Different Parts within a Level

Based on the properties of `director.js`, we realized that we can extend director and apply it to creating a `pipe` entity, which can take an arbitrary `key:value` pair representing the position/level to warp the `player.js` entity to. The following is the `check()` method for the `pipe.js` entity:

{% highlight javascript linenos %}
    update: function() {this.parent();},

        // Handle player transitions to different levels
        check: function(other) {
            // Entity is on pipe but not using it
            if(other.pos.y <= this.pos.y - other.size.y + 4 && !this.usingPipe) {
                other.pos.y = this.pos.y - other.size.y;
                // Entity is player; handles player animations (If entity is not player ignore entity)
                if(other instanceof EntityPlayer) {
                    this.onPipe = true;
                    // Handle player's movements while on pipe
                    if(ig.input.state('left') || ig.input.state('right')) {
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_run;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_run;
                        else
                            other.currentAnim = other.anims.run;
                    } else if(ig.input.state('jump')) {
                        other.vel.y = -other.jump;
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_jump;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_jump;
                        else
                            other.currentAnim = other.anims.jump;
                    } else {
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_idle;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_idle;
                        else
                            other.currentAnim = other.anims.idle;
                    }

                    // Player uses pipe and is standing within acceptable boundaries of pipe
                    if(ig.input.state('continue') && this.onPipe && other.pos.x > this.pos.x && other.pos.x < this.pos.x + other.size.x) {
                        // Reposition player to center of pipe
                        other.pos.x = this.pos.x + this.size.x/2 - other.size.x/2;
                        // Start pipe usage
                        this.usingPipe = true;
                    }
                }
            // Entiy not on pipe
            } else if(!this.usingPipe) {
                // Entity is player; handle player-specific repositioning ("fake collision")
                if(other instanceof EntityGameplayer) {
                    this.onPipe = false;
                    if(other.pos.x <= this.pos.x)
                        other.pos.x = this.pos.x - other.size.x;
                    else
                        other.pos.x = this.pos.x + this.size.x;
                // Entity is not player; handle other entity's repositioning
                } else {
                    other.flip = !other.flip;
                    other.currentAnim.flip.x = other.flip;
                }
            // Player is using pipe
            } else {
                // Play some player "using pipe" animation and begin to descend player down pipe
                if(ig.main.activePower == "EntityHammer")
                    other.currentAnim = other.anims.hammer_idle;
                else if(ig.main.activePower == "EntityFireball")
                    other.currentAnim = other.anims.fire_idle;
                else
                    other.currentAnim = other.anims.idle;
                other.vel.y = this.pipeSpeed;
                // If player is using pipe, make sure player STAYS IN THE PIPE!
                other.pos.x = this.pos.x + this.size.x/2 - other.size.x/2;
                // Player is completely inside pipe
                if(other.pos.y > this.pos.y) {
                    // Handle level transitioning
                    // Level property has been set in Weltmeister
                    if(this.level !== null && this.level >= 0) {
                        // Transition to specified level
                        ig.game.myDirector.loadLevel(this.level);
                    // Level property has NOT been set in Weltmeister
                    } else if(this.level === null) {
                        // Transition to next level
                        ig.game.myDirector.nextLevel();
                    }

                    // Spawn position has been set in Weltmeister
                    if(this.spawn.x !== null && this.spawn.y !== null) {
                        // Move player to specified (x, y) position of new level
                        my_player.pos.x = this.spawn.x;
                        my_player.pos.y = this.spawn.y;
                    }
                }
            }

{% endhighlight %}

With this, we were able to use pipes to transition to bonus levels or to go to different portions within a level (as well as return), just like the original Super Mario World!

#### Overworld

As one last aesthetic feature, we decided to tackle creating an overworld. The first task was to figure out how to transition between different game states within ImpactJS, while still having a reference to levels and the player entity without making these global variables. Due to having a top-down perspective for the overworld (as opposed to side-scrolling in the main game), a different player entity was necessary to be used on the overworld (along with its own set of physics and properties). This proved to be a major task due to confusion of how `director.js` worked in tandem with ImpactJS's `loadLevel()` method. After roughly 45 days of working on a solution, we tailored `director.js` further (the changes were included in the listing provided earlier) and made the following changes to `main.js`:

{% highlight javascript linenos %}
    update: function() {
        /* This code allows the camera to follow the player
           by overriding the update function using the method
           of the game class called `getEntitiesByType()`.
           This API allows us to find instances of entities in
           our game. */

        var player = this.getEntitiesByType( EntityPlayer )[0];
        if( player ) {
            this.camera.follow(this.player);
            //this.screen.x = player.pos.x - ig.system.width/2;
            //this.screen.y = player.pos.y - ig.system.height/2;
            // If the player moves, erase the instructions
            if(player.accel.x > 0 && this.font)
                this.font = null;
        }
        // Update all entities and backgroundMaps
        /* We need to change this code to pull up the stat screen.
           We test if it is time to show the stats screen. If it
           is not being displayed, we call "this.parent()" and the
           game continues normally. Otherwise, we listen for an input
           state 'continue' */
        if(!this.showStats && !this.showEnding){
            this.parent();
        } else {
            if(ig.input.pressed('continue')) {
                this.parent();
                if(this.myDirector.currentLevel !== this.finalStage || this.finalStageEnabled) {
                    this.showEnding = false;
                    this.showStats = false;
                    this.maxStage = this.myDirector.currentLevel;
                    this.myDirector.loadLevel(1);
                    ig.music.play(1);
                } else {
                    this.showEnding = false;
                    this.showStats = false;
                    if(this.lives < this.bonusReqLives || this.finalStageEnabled) {
                        ig.system.setGame(StartScreen);
                    } else {
                        this.finalStageEnabled = true;
                        this.maxStage = this.myDirector.currentLevel;
                        this.myDirector.loadLevel(1);
                        ig.music.play(1);
                    }
                }
            }
        }
{% endhighlight %}

After having the ability to transition between different game states while swapping out different entities based on the level, a beautiful custom overworld was built from scratch:

![Koopa Krisis Overworld]({{ site.url }}/img/koopa-krisis/overworld.png)

#### Final Boss

Wrapping up our development time before releasing our game, we knew we needed a final boss that was both challenging yet beatable. After brainstorming and planning out the behavior of our boss, it was time to undertake the creation of `iggy_koopa.js`. The behavior is outlined below:

{% highlight javascript linenos %}

/*
Iggy Koopa
----------
A boss featuring the combination of AIs from currently existing enemies (at the
time of implementation):
  1. [Modified] Stalker AI from Flying Yellow Koopa.
  2. [Modified] Protection/Spiky state from Bony Beetle (new).
  3. Linear multi-attack projectiles from Bullet Shooter.
  4. [Modified] Independent multi-attack projectiles from Hammer Bros.
  5. Skipping (jumping while moving) AI from Flying Green Koopa.
  5. [Modified] Randomized jumping from Jumping Ninji.

Custom/Derived AIs:
  1. Derived from stalker --> Waits until provoked by player or if player is near.
  2. Derived from protection/spiky state --> Random protection/spiky state duration.
  3. Derived from protection/spiky state --> Panick state.
  4. Derived from randomized jumping --> Random jump frequency with random jump height.
  5. Derived from linear attack projectiles --> linear attack projectiles with random spread.
  6. Multiple health-based AI stages.
  7. Anti-"I cannot reach player" AI.
  8. Anti-"hammer/fireball damage abuse" AI.
  9. Anti-"enemy abuse player" and anti-"player abuse enemy" grace period.
  10. Auto-complete level on death.


----- Initial/Basic AI -----
1. Enemy will initially remain stationary until player comes within detection
   range or enemy is provoked (such as if player attacks from afar).
2. If enemy has lost track of player, enemy defaults to basic left/right
   movement. Enemy will move in the opposite direction if it collides with an
   obstacle.

----- Detection/Chase AI -----
3. If player is near enemy but NOT in enemy's line-of-sight (LoS), enemy
   ignores player and uses default AI. Enemy's LoS is a rectangular
   field-of-view directly in front of itself.
4. If enemy detected player (either by distance or by provoke), enemy begins
   chasing player and extends its detection range.
   a. If enemy is following player and player moves behind enemy, enemy faces
      player and continues to chasing.
   b. If enemy is following player and player steps out of enemy's detection
      range, enemy stops following player and resets to default AI.
5. If enemy detected player and player is above enemy for too long (enemy cannot
   reach player), enemy will increase its average jump height (still random) in
   an attempt to overcome obstacle.
6. Extending from #5: If enemy still cannot reach player and enemy is not in
   angry or rampage state, give up and patrol (walk left and right) around the
   immediate area. If it cannot reach player while in angry or rampage state,
   continue to chase player indefinitely. If enemy redetects player after giving
   up, restart chasing AI.
7. If player is killed, stop detection and chasing to give player time to
   rethink strategy (for a short time). If enemy redetects player afterwards,
   restart chasing AI.

----- Randomized Jumping while Moving AI -----
8. Enemy will jump while moving.
9. Enemy will jump random heights at random intervals.
   a. Enemy may jump when firing its attack causing attack projectiles to be
      launched at jump height.
   b. See #5.

----- Protection/Shell State AI -----
10. If the player jumps on enemy when enemy is NOT in shell state, enemy will
    take damage and enter shell state (a spinning shell).
    a. In shell state, if the player jumps on enemy, player takes extra damage.
    b. Enemy will unhide (exit shell state) and revert back to default AI after
       some time has passed regardless if player is near enemy or not.
    c. Enemy duration in shell state is determined by its current AI state. The
       higher the AI state (the lower the enemy's health is), the longer the
       duration.
    d. Panick state: If enemy is in panick state and enemy enters shell state,
       enemy remains in shell state indefinately until player moves far enough
       away from enemy. While in panick state, if player is still within range,
       enemy will begin to fire projectiles randomly while in shell state. As the
       enemy's health decreases, the frequency of firing random projectiles
       increases. If player is killed while enemy is in panick shell state, enemy
       will exit shell state.

----- Multiple Health-based AI -----
11. Enemy has 3 sets of attack AIs: default, annoyed, and angry AI states.
    a. Default state: Enemy is notably faster than the average enemy. Enemy
       fires a single attack projectile in front of itself at random time
       intervals.
    b. Annoyed state: Enemy is slightly faster than default state, and shell time
       increases. Enemy fires three attack projectiles at same time in front of
       itself in a triangular formation. Center projectile is same as default
       state's projectile. Top and bottom projectiles have randomized spread
       angle with a linear trajectory.
    c. Angry state: Enemy is moderately faster than default state, and shell time
       further increases. Enemy fires 8 attack projectiles around itself in a
       circular formation. Each of the projectiles are fired at a difference of
       45-degree angle in a linear trajectory.
    d. Rampage state: Enemy is much faster than default state, attack frequency
       increases, and attack projectile speed increases. Enemy shoots a single
       projectile directed towards player's position at firing time. Enemy's
       movement and attack projectile speed linearly increases as its health
       continues to decrease.

----- Anti-camping AI -----
12. Enemy has anti-camping AIs. (camping = tactic where player obtains static
    strategic position of advantage)
    a. If player is on unreachable for long enough, enemy will fire a single attack
       projectile upwards/downwards towards player in hopes of threatening player
       above/below.
    b. Enemy will not jump up if directly below player to prevent auto-taking
       damage and auto-entering shell state (due to #7).
    c. See #5.

----- Obstacle Traversal AI -----
13. Enemy will attempt to climb/jump over short obstacles or walls if it is
    chasing player and bumps into obstruction.
14. See #5.

----- Abuse protection -----
15. Enemy cannot be abused from non-player damage projectiles as much.
    a. Damage from non-player projectiles that hits enemy is nerfed to 1 damage.
16. Enemy enters grace period under which during that time, enemy will not chase
    player, will not shoot projectiles, and collision damage to player is
    negated.
    a. Player cannot (or should not) abuse this grace period as player's damage
       to the enemy during this time will also be negated
17. If player is killed while enemy is in panick shell state, enemy will exit
    shell state. This is to prevent enemy from spamming attack projectiles near
    respawn zone and not giving player a chance to escape.
18. See #9b.

----- Game/Level controllers -----
19. Defeating enemy will automatically end level.
    a. This feature can be disabled in the enemy's properties.

*/

{% endhighlight %}

And the actual implementation of this beast is shown below: 

{% highlight javascript linenos %}

ig.module('game.entities.enemies.iggy_koopa')
.requires('game.entities.ai.basic_ai')

.defines(function() {
    EntityIggy_koopa = EntityBasic_ai.extend({
        // Add animation and set collision
        animSheet: new ig.AnimationSheet('media/enemies/iggy_koopa_full.png', 32, 32),
        size: {x: 28, y: 29},
        offset: {x: 3, y: 3},
        flip: true, // Enemy faces left

        // Override Basic AI default properties
        health: 45, // Enemy health when spawned; Default: 55
                    // NOTE: Don't set health too low since it may skip certain AI stages;
                    //       Don't set health too high since it will be VERY hard to kill near the end (don't say I didn't warn you)
                    // NOTE: If you update health, be sure to update the ai_state_health property values below relative to new health
        maxVel: {x: 500, y: 250}, // NOTE: If you update maxVel, be sure to update the jump_height property values and speed values below relative to new maxVel
        speed: 50, // Default horizontal movement speed; Default: 40
                   // NOTE: If you update speed, be sure to update the this.speed values below relative to new speed
        collide_damage: 1, // Default player damage when colliding with enemy; Default: 1
        damage_jump: -125, // Default vertical player jump distance when colliding with enemy vertically; Default: -125
        damage_push: 125, // Default horizontal player push distance when colliding with enemy horizontally; Default: 125
        kill_score: 9001, // Just because it's a "boss-type" enemy :)
        maxHealth: 45,

        // ----- Begin custom properties -----
        // Game/Level properties
        exit_when_killed: true, // Exit level (and display stats screen) when enemy is killed

        // AI state properties
        grace_time: 4, // Grace (non-agression) time to allow player a chance to escape if enemy is camping player respawn zone on player death
        ai_state: 0, // 0 = default, 1 = annoyed, 2 = angry, 3 = rampage
        ai_state_health: {annoyed: 35, angry: 25, rampage: 10, panick: 15}, // Health values at which the enemy's AI will switch

        // Detection properties
        icu_check_dist: {x: 150, y: 65}, // x, y distance enemy will detect player at
        icu_chase_dist: {x: 600, y: 300}, // x, y distance enemy will chase player at (span almost the entire map)

        // Attack projectile properties
        attack_damage: 2, // damage inflicted from attack projectiles if collide with player by default
        unreachable_damage: 5, // damage inflicted from attack projectiles if collide with player if player is unreachable
        projectile_speed: 110, // Speed of attack projectile
        attack_spread: {base: 60, delta: 15}, // base and variable y-component of projectile spread
        attack_interval: {min: 1, max: 4}, // minimum and maximum range of seconds between attacks (generated randomly)
        attack_charge: 0.7, // seconds between stopping/charging and launching attack projectile (used in conjuntion with animation speed)

        // Protection/Shell state properties
        shell_hide_time: {base: 1, min: 0, max: 1}, // seconds to hide in shell before returning to normal state
        shell_panick_attack_wait_time: 4, // seconds before enemy starts spewing attack projectiles while in panick state and in shell

        // Jump properties
        jump_interval: {min: 2, max: 4}, // minimum and maximum range of seconds between jumping (generated randomly)
        jump_height: {min: -50, max: -100}, // minimum and maximum range of height in which to jump (generated randomly)
        unreachable_patience: 15, // seconds at which enemy will wait until it suspects player is unreachable
        // ----- End custom properties -----

        init: function(x, y, settings) {
            this.parent(x, y, settings);

            // Set up animation states
            this.addAnim('idle', 1, [0], true); // Initial animation
            this.addAnim('crawl', 0.2, [0,1]);
            this.addAnim('attack', 0.1, [2,3,4,5,6,7,8,9]);
            this.addAnim('shell', 0.05, [10,11,12,13,14,15]);

            // Correct idle animation flip
            this.anims.idle.flip.x = this.flip;
            this.anims.attack.flip.x = this.flip;

            // Timers
            this.shootTimer = new ig.Timer();
            this.shellTimer = new ig.Timer();
            this.jumpTimer = new ig.Timer();
            this.unreachableTimer = new ig.Timer();
            this.graceTimer = new ig.Timer();

            // Flags
            setAtkTime = false; // Is attack interval timer set?
            setJumpTime = false; // Is jump interval timer set?
            panick = false; // Is enemy in panick state?
            inShell = false; // Is enemy in shell state?

            // Comparason variables
            max_health = this.health; // Maximum health to check enemy's condition
            provoke_health = this.health; // Initial health to check if enemy has been provoked

            // Temporary variables
            this.graceTimer.set(-this.grace_time);
            speed_tmp = 0; // Wait until enemy detects player via detection AI
            shell_hide_time_tmp = this.shell_hide_time; // Used to allow hide time back to be reverted to default
            icu = false; // Has enemy detected player?
        }, // End init method

        update: function() {
            my_player = ig.game.getEntitiesByType('EntityPlayer')[0];

            // Move forward in flip direction
            var xdir = this.flip ? -1 : 1;
            this.vel.x = speed_tmp * xdir;

            // Enter panick state if enemy's health is low
            if(this.health <= this.ai_state_health.panick)
                panick = true;

            // Reset patience timer if player is within reachable height
            if((my_player.pos.y >= this.pos.y + my_player.size.y) || (my_player.pos.y >= this.pos.y - this.size.y))
                this.unreachableTimer.set(0);

            // Enemy is not angry or in rampage state, is chasing player but cannot reach player for a long time even after out-of-patience mode --> Give up, reset patience timer and don't chase anymore
            if(icu && this.unreachableTimer.delta() > this.unreachable_patience * 3 && this.health > this.ai_state_health.angry) {
                this.currentAnim = this.anims.crawl;
                this.unreachableTimer.set(0);
                icu = false;
            }

            // Update properties for new AI state if health reaches certain amount
            if(this.ai_state != 3) {
                if(this.health <= this.ai_state_health.annoyed && this.health > this.ai_state_health.angry && this.ai_state == 0) {
                    // Annoyed state
                    this.speed = 65; // Increase movement speed
                    this.shell_hide_time.base += 0.5; // Increase shell state time
                    this.shell_hide_time.min += 0.5; // Increase shell state time
                    this.shell_hide_time.max += 0.5; // Increase shell state time
                    this.attack_interval.min = 1.5; // Decrease frequency of attacks
                    this.attack_charge = 1.05; // 1.5x attack charge time to compensate for increased projectiles
                    this.projectile_speed = this.speed * 1.846; // Increase projectile speed relative to movement (so player doesn't get trapped between fast enemy and slow projectile)
                    this.ai_state = 1;
                } else if(this.health <= this.ai_state_health.angry && this.health <= this.ai_state_health.rampage && this.ai_state == 1) {
                    // Angry state
                    this.speed = 80; // Increase movement speed
                    this.shell_hide_time.base += 1; // Increase shell state time
                    this.shell_hide_time.min += 0.5; // Increase shell state time
                    this.shell_hide_time.max += 1; // Increase shell state time
                    this.attack_interval.min = 2; // Decrease frequency of attacks
                    this.attack_charge = 1.4; // 2x attack charge time to compensate for increased projectiles
                    this.projectile_speed = this.speed * 1.625; // Increase projectile speed relative to movement (so player doesn't get trapped between fast enemy and slow projectile)
                    this.ai_state = 2;
                } else if(this.health <= this.ai_state_health.rampage && this.ai_state == 2) {
                    // Rampage state
                    this.speed = 105 - this.health; // Increase movement speed; speed up further as health decreases
                    this.attack_interval.min = 1.25; // Increase frequency of attacks
                    this.attack_interval.max = 2.5; // Increase frequency of attacks
                    this.attack_charge = 0.7; // Return to default attack charge time due to decreased projectiles
                    this.jump_interval.min = 1.5; // Increase frequency of jumping
                    this.jump_interval.max = 3.5; // Increase frequency of jumping
                    this.jump_height.min *= 1.15; // Increase jump height
                    this.jump_height.max *= 1.15; // Increase jump height
                    this.projectile_speed = this.speed * 1.555; // Increase projectile speed relative to movement (so player doesn't get trapped between fast enemy and slow projectile)
                    this.ai_state = 3;
                } else if(this.ai_state == 3) {
                    // Rampage state (update AI)
                    this.speed = 105 - this.health; // Increase movement speed; speed up further as health decreases
                    this.projectile_speed = this.speed * 1.555; // Increase projectile speed relative to movement (so player doesn't get trapped between fast enemy and slow projectile)
                }
            }

            // Enemy not in shell state --> Use default AI
            if(!inShell) {
                // Randomize interval between jumps
                if(!setJumpTime) {
                    jump_dur = this.randomRange(this.jump_interval.min, this.jump_interval.max);
                    setJumpTime = true;
                // Enemy is on the ground, is moving (not in attack animation), and jump interval duration has elapsed,
                } else if(this.standing && this.vel.x && this.jumpTimer.delta() > jump_dur) {
                    // Player is not directly on top or below enemy (prevents auto-killing itself if enemy keeps jumping under player)
                    if(this.pos.x > my_player.pos.x + my_player.size.x || my_player.pos.x > this.pos.x + this.size.x) {
                        // Jump at random height
                        if(this.unreachable_patience > this.unreachableTimer.delta())
                            this.vel.y = this.randomRange(this.jump_height.min, this.jump_height.max);
                        // Player is too high above enemy for too long (assume player is camping on top of a ledge or across an obstacle)
                        else
                            this.vel.y = this.randomRange(this.jump_height.min * 2, this.jump_height.max * 1.5);
                        this.jumpTimer.set(0);
                    }
                }

                // Is player alive?
                if(my_player != null && this.grace_time < this.graceTimer.delta()) {
                    // Get player's position
                    var target_x = 0;
                    var target_y = 0;
                    target_x = my_player.pos.x;
                    target_y = my_player.pos.y;
                    var distToPlayer_x = Math.abs(target_x - this.pos.x);
                    var distToPlayer_y = Math.abs(target_y - this.pos.y)

                    // Player is within enemy's potential detection range but has not detected player yet **OR** Enemy is provoked from player attacking it from afar
                    if((!icu && distToPlayer_x <= this.icu_check_dist.x && distToPlayer_y <= this.icu_check_dist.y) || this.health < provoke_health) {
                        // Player in enemy's line-of-sight --> Begin chasing behavior
                        if((target_x > this.pos.x && !this.flip) || (target_x < this.pos.x && this.flip)) {
                            // Start moving and play walking animation
                            this.anims.crawl.flip.x = this.flip;
                            this.anims.attack.flip.x = this.flip;
                            this.currentAnim = this.anims.crawl;
                            speed_tmp = this.speed;
                            icu = true;

                            // Enemy is provoked --> start chasing player; do not need to check if provoked again
                            provoke_health = null;

                            // Reset shoot timer to prevent instant firing attack projectile when start chasing
                            this.shootTimer.set(0);
                            setAtkTime = false;
                        }
                    // Enemy has detected player --> Begin chasing behavior; Extend detection/chasing range
                    } else if(icu && distToPlayer_x <= this.icu_chase_dist.x && distToPlayer_y <= this.icu_chase_dist.y) {
                        // Player is behind enemy --> Enemy faces player
                        if((target_x < this.pos.x && !this.flip) || (target_x > this.pos.x && this.flip)) {
                            this.flip = !this.flip;
                            this.anims.crawl.flip.x = this.flip;
                            this.anims.attack.flip.x = this.flip;
                        }

                        // Set attack interval time
                        if(!setAtkTime) {
                            // Randomize interval between attacks
                            atk_dur = this.randomRange(this.attack_interval.min, this.attack_interval.max);
                            setAtkTime = true;
                        // Attack procedure
                        } else if(this.shootTimer.delta() > atk_dur) {
                            // Stop moving and play attack animation
                            speed_tmp = 0;
                            this.currentAnim = this.anims.attack;

                            // Attack interval duration has elapsed
                            if(this.shootTimer.delta() > atk_dur + this.attack_charge) {
                                // Stage 0 AI: Player tries to be smart by camping above/below enemy...
                                if(this.unreachable_patience < this.unreachableTimer.delta()) {
                                    // Fire projectile above enemy! :)
                                    if(my_player.pos.y < this.pos.y + my_player.size.y)
                                        ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.unreachable_damage, speed: {x: 0, y: -this.projectile_speed}});
                                    // Fire projectile below enemy! :)
                                    else
                                        ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.unreachable_damage, speed: {x: 0, y: this.projectile_speed}});
                                // Stage 1 AI: Single frontal projectile
                                } else if(this.health > this.ai_state_health.annoyed) {
                                    // Fire projectile in front of enemy
                                    ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed, y: 0}});
                                // Stage 2 AI: Triple frontal projectiles with randomized spread
                                } else if(this.health > this.ai_state_health.angry) {
                                    // Fire 3 projectiles in front of enemy
                                    ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed, y: Math.random() * -this.attack_spread.delta - this.attack_spread.base}});
                                    ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed, y: 0}});
                                    ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed, y: Math.random() * this.attack_spread.delta + this.attack_spread.base}});
                                // Stage 3 AI: Circular projectiles
                                } else if(this.health > this.ai_state_health.rampage) {
                                    // Fire 8 projectiles around enemy
                                    var ring_count = 8;
                                    var angle_delta = 2 * Math.PI / ring_count;
                                    for(var i = 0; i < ring_count; i++) {
                                        ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed * Math.cos(i * angle_delta), y: this.projectile_speed * Math.sin(i * angle_delta)}});
                                    }
                                } else {
                                    // Fire projectile in direction of player
                                    var dist_x = this.pos.x - target_x;
                                    var dist_y = this.pos.y - target_y;
                                    var angle_delta = Math.tan(dist_y / dist_x);
                                    ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed * Math.cos(angle_delta), y: this.projectile_speed * Math.sin(angle_delta)}});
                                }

                                // Reset timer and animation
                                this.currentAnim = this.anims.crawl;
                                this.shootTimer.set(0);
                                speed_tmp = this.speed;
                                setAtkTime = false;
                            }
                        }
                    }
                }
            // Enemy is in shell state
            } else {
                // Stop moving and play shell animation
                this.currentAnim = this.anims.shell;
                speed_tmp = 0;
                shell_hide_time_tmp = this.shell_hide_time.base + this.randomRange(this.shell_hide_time.min, this.shell_hide_time.max);

                // Not in panick mode and shell duration exceeded **OR** in panick mode and player is out of range
                if((!panick && this.shellTimer.delta() > shell_hide_time_tmp) ||
                    (panick && this.distanceTo(my_player) > this.icu_check_dist.x)) {
                        // Reset and return to default state
                        this.currentAnim = this.anims.crawl;
                        inShell = false;
                        this.shellTimer.set(0);
                        speed_tmp = this.speed;

                        // Reset attack timer to prevent instant attack afterwards
                        this.shootTimer.set(0);
                        setAtkTime = false;
                // In panick mode and player is in range --> Start shooting projectiles randomly
                } else if(panick && this.distanceTo(my_player) < this.icu_check_dist.x) {
                    if(!setAtkTime) {
                        this.shootTimer.set(0);
                        setAtkTime = true;
                    // Frequency of shooting projectiles increases as enemy's health decreases
                    } else if(this.shootTimer.delta() > ((Math.pow(this.health, 1.1) / max_health) + this.shell_panick_attack_wait_time)) {
                        // Shoot a single projectile in a random direction
                        var angle_delta = Math.random() * 2 * Math.PI;
                        ig.game.spawnEntity(EntityRing, this.pos.x, this.pos.y, {flip: !this.flip, damage: this.attack_damage, speed: {x: this.projectile_speed * Math.cos(angle_delta), y: this.projectile_speed * 1.5 * Math.sin(angle_delta)}});
                        this.shootTimer.set(-this.shell_panick_attack_wait_time);
                    }
                }
            }

            this.parent();
        }, // End update method

        randomRange: function(min, max){
            return Math.random() * (max - min) + min;
        },

        // Add on to Basic AI's collideWith method
        handleMovementTrace: function(res) {
            this.parent(res);

            // If the enemy collides with an obstacle and is chasing player, climb/jump over obstacle.
            if(res.collision.x)
                if(icu && this.standing)
                    this.vel.y = this.jump_height.max * 1.5;
        }, // End handleMovementTrace method

        // Override Basic AI's collideWith method
        collideWith: function(other, axis) {
            // Only do something if colliding with the Player
            if(other instanceof EntityPlayer) {
                if(this.grace_time < this.graceTimer.delta()) {
                    // Player falls on enemy
                    if(axis == 'y' && this.pos.y > other.pos.y) {
                        // Enemy is not in shell state --> Do damage to enemy and enter shell state
                        if(!inShell) {
                            this.receiveDamage(1, other);
                            inShell = true;
                            this.shellTimer.set(0);
                        // Enemy just entered shell state --> Push player back but player takes no damage
                        } else if(this.shellTimer.delta() < 0.1) {
                            other.vel.y = axis == 'y' ? this.damage_jump * 1.5 : 0;
                            other.vel.x = (other.pos.x + other.size.x/2) > (this.pos.x + this.size.x/2) ? this.damage_push * 1.5 : -this.damage_push * 1.5;
                        // Enemy is already in shell state --> Push player back and player takes extra damage
                        } else {
                            other.receiveDamage(this.collide_damage * 2, this);
                            other.vel.y = axis == 'y' ? this.damage_jump : 0;
                            other.vel.x = (other.pos.x + other.size.x/2) > (this.pos.x + this.size.x/2) ? this.damage_push * 1.25 : -this.damage_push * 1.25;
                        }
                    // Player collides with enemy horizontally --> Push player back and do damage.
                    } else {
                        other.receiveDamage(this.collide_damage, this);
                        other.vel.x = other.pos.x > this.pos.x ? this.damage_push : -this.damage_push;
                    }

                    // Player is killed --> Exit shell state and stop chasing
                    if(other.health <= 0) {
                        // Stop chasing, enable grace time
                        this.unreachableTimer.set(0);
                        this.graceTimer.set(0);
                        icu = false;

                        // Reset and return to default state
                        this.currentAnim = this.anims.crawl;
                        inShell = false;
                        this.shellTimer.set(0);
                        speed_tmp = this.speed;

                        // Reset attack timer to prevent instant attack afterwards
                        this.shootTimer.set(0);
                        setAtkTime = false;
                    }
                } else {
                    var sign_x = other.vel.x ? other.vel.x < 0 ? -1 : 1 : 0;
                    var sign_y = other.vel.y ? other.vel.y < 0 ? -1 : 1 : 0;
                    other.vel.x = sign_x * this.damage_push / 2;
                    other.vel.y = sign_y * this.damage_jump / 2;
                }
            }
        }, // End collideWith method

        // Add on to Basic AI's kill method
        kill: function() {
            this.parent();

            // End level and display stats screen
            if(this.exit_when_killed) {
                ig.game.toggleEnding(this);
            }
        }, // End kill method

        // Add on to Basic AI's receiveDamage method
        receiveDamage: function(value, other) {
            // If under grace period, negate incoming damage completely
            if(this.grace_time > this.graceTimer.delta())
                value = 0;
            // If receiving damage due to non-player collision (assume hammer or fireball) --> Nerf damage to 1
            else if(!(other instanceof EntityPlayer))
                value = 1;
            this.parent(value, other);
        } // End receiveDamage method
    }); // End EntityIggy_koopa

    // Iggy Koopa's Ring Attack Projectile
    EntityRing = ig.Entity.extend({
        // Set up collision
        type: ig.Entity.TYPE.NONE,
        checkAgainst: ig.Entity.TYPE.A,
        collides: ig.Entity.COLLIDES.PASSIVE,

        // Add animation and set collision
        animSheet: new ig.AnimationSheet('media/enemies/attack.png', 16, 16),
        size: {x: 16, y: 16},

        // Set speed
        maxVel: {x: 165, y: 165},
        speed: {x: 0, y: 0},
        gravityFactor: 0, // Prevent gravity from altering projectile's trajectory

        damage: 1, // Set default damage for projectile

        init: function(x, y, settings) {
            this.parent(x, y, settings);

            // Set up animation states
            this.addAnim('idle', 1, [0]);

            // Set initial direction and speed
            var xdir = this.flip ? 1 : -1;
            this.vel.x = this.speed.x * xdir;
            this.vel.y = this.speed.y;
            this.anims.idle.flip.x = this.flip;

            // Load player object if not in Weltmeister
            if(!ig.global.wm)
                my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
        }, // End init method

        update: function() {
            this.parent();

            // Clean up: Auto-kill this entity if too far from player to prevent having too many entities on screen
            if(this.distanceTo(my_player) > ig.system.width)
                this.kill();
        }, // End update method

        handleMovementTrace: function(res) {
            // Override entity's collision against walls so it can pass through them.
            this.pos.x += this.vel.x * ig.system.tick;
            this.pos.y += this.vel.y * ig.system.tick;
        }, // End handleMovementTrace method

        check: function(other) {
            // Damage player and destroy this entity
            other.receiveDamage(this.damage, this);
            my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
            this.kill();
        } // End check method
    }); // End EntityRing
}); // End .defines

{% endhighlight %}

As seen above, `iggy_koopa.js` is a combination of all techniques learned while creating entities of varying AI for our game, while putting to use the OOP skills gained throughout this project. At its core, this boss gets more and more difficult as his Hit Points (HP) drops, increasing both his speed of movement and attacks, as well as using different attacks on the player. These attacks include:

* Stalking the player and firing projectiles at a random angle
* Stalking the player, computing a projectile trajectory and firing
* A 'burst' attack of projectiles

As a fun, extra touch: if the player beats `iggy_koopa` with 10 or more lives, they can go on to challenge an insanely difficulty level containing (with no midpoints!) with the finale being a painful but entertaining new boss room.

#### Challenges and Experiences

Overall, Super Mario World Koopa Krisis was a huge success. Along with my group, I gained a lot of experience with JavaScript and learned more of the advantages of Object Oriented Programming firsthand, along with becoming more familiar with the ImpactJS Game Engine. 

The biggest challenges faced during this project revolved around transitioning between different game states (a main game and an overworld state), as well as working around the limitations of ImpactJS's `sound` class. One big challenge I personally faced was leading a large group and being able to break down tasks to their most basic form, as well as giving primer lessons on the game engine and JavaScript. In the end, it was a great experience for me as a leader on a project and helped push me to write clean, efficient code for others to understand, while learning as much as possible to pass it on to my dedicated members. 

In the end, our group stayed together and we decided to tackle a far more complex game, a remake of Fire Emblem - Blazing Sword from the Game Boy Advanced. To view the current progress of my new project, you may do so <a style="color:red" href="http://drksephy.github.io/2014/03/30/fireemblem.html">here.</a>


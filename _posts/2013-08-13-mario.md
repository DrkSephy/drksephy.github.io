---
layout: portfolio_entry
title: Super Mario World Koopa Krisis
image: /img/koopa-krisis/titlescreen.png
---

Super Mario World - Koopa Krisis is a JavaScript remake of Super Mario World, built on top of the ImpactJS Game Engine, purely for educational purposes. The motivation of this project is to create a browser-only version of one of the most iconic games in the history of Nintendo, and to further my knowledge of JavaScript and the ImpactJS framework.

#### Motivation 

As the new leader of CCNY ACM's Game Development group for the Fall 2013 - Spring 2014 year, I decided to experiment with the ImpactJS Game Engine after being exposed to it in Fall 2012. I decided to begin working on a simple platformer game in late July, which soon turned out to be heavily based on Super Mario World. My motivation was to create a skeleton game which others could build on top of, and to produce a well polished game at the end of the Fall 2013 semester. Once our Game Development club meetings started, I assembled a team of 5 others and development began. 

#### Development Roadmap

My team this semester was very enthusiastic about this game, and so I knew that a detailed listing of all tasks needed to be done. After spending a session explaining the game engine, basic JavaScript and how projects are structured using ImpactJS, my group quickly caught on and started to work on their respective tasks. A list of comprehensive tasks are shown below:

* Artificial Intelligence of Enemies
    * Understanding the ImpactJS Game loop 
    * Graphics for Enemies
* Powerup System
    * Various powerups
    * Powerup transitions when getting hit
* Collectible Items
    * Coins
    * Free lives
* Ability to transition between levels
    * Ability to have different songs per level
* Ability to use pipes to transition to levels
* Sloped tile movement
* Level building
    * Asset gathering

I decided to give each member of my team 1-2 different enemies each week to work on, while providing a skeleton file containing the animation frames already set up, as well as detailed descriptions of enemy behavior coupled with videos of demonstration for those not familiar with Super Mario World. In the meantime, I would work on various systems such as the powerups, collectible items, level building and other things critical to the gameplay itself.

#### Understanding the ImpactJS Game Loop

To discuss creating enemy AI, we must first understand ImpactJS's game loop. Any object that can interact within the game's environment is called an `entity`, and therefore creating new enemies is the same as creating a new entity. Each entity has their own base methods which can be extended. To make our codebase modular, we created a base entity named `basic_ai.js` which contains these methods, allowing us to extend from it and have our new entities inherit the properties from `basic_ai.js` and drastically make our codebase more readable. The following is a listing of the important methods found within our `basic_ai.js` module:

{% highlight javascript linenos %}
    
    init: function(x, y, settings) {
            // Init method is used for setting up animations
            // and temporary variables
            this.parent(x, y, settings);

            // Set up animations
            /** Animations should be handled by each enemy. **/
            this.healthTimer = new ig.Timer();
            tempHealth = this.health;
            // Load player object if not in Weltmeister
            if(!ig.global.wm)
                my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
        }
{% endhighlight %}

{% highlight javascript linenos %}
     // handleMovementTrace is mostly for checking collisions
     // against other entities in conjunction with the 
     // `collidesWith method.
     handleMovementTrace: function(res) {
            this.parent(res);

            // If the enemy collides with a wall, make them turn around.
            if(res.collision.x) {
                this.flip = !this.flip;
                this.currentAnim.flip.x = this.flip;
            }
        }, 
    
{% endhighlight%}

{% highlight javascript linenos %}
    // Collisions with player are handled through the following function.
        /** Certain enemies with advanced collisions may wish to override this
            function with their own collision handling code. **/
        collideWith: function(other, axis) {
            // Only do something if colliding with the Player
            if(other instanceof EntityPlayer) {
                // Prevents enemy from being killed from below.
                if(axis == 'y' && this.pos.y > other.pos.y) {
                    other.vel.y = this.damage_jump;
                    this.kill();
                } else {
                    other.receiveDamage(this.collide_damage, this);
                    // Push player back if collides with enemy horizontally.
                    if(other.pos.x > this.pos.x)
                        other.vel.x = this.damage_push;
                    else
                        other.vel.x = -this.damage_push;
                }
                
                // If player's health <= 0 (player dead), re-detect player
                // entity (respawned player).
                if(other.health <= 0)
                    my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
            }
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Simply setting up collisions isn't enough, we must create a method
    // which will check if a collision occurs. This method overrides the
    // .check() function, which gets called when a collision is detected,
    // and applies damage to the entity it collides with.
    check: function(other, axis) {
            if(other instanceof EntityPlayer)
                if(axis == 'x')
                    other.receiveDamage(this.collide_damage, this);
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy's death (and player's rewards from enemy's death) is handled
    // through the following function.
        kill: function() {
            ig.game.stats.kills++;
            ig.game.increaseScore(this.kill_score);
            ig.game.spawnEntity(EntityDeathExplosionParticle, this.pos.x, this.pos.y, {particles:2, colorOffset: 1});
            this.parent();
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy receiving damage is handled through the following function.
        receiveDamage: function(value) {
            this.parent(value);
            this.healthTimer.set(0);
        }
{% endhighlight %}

With these methods written, there only remains two methods needed to implement: `draw()` and `update()`. Both of these methods are called on every frame of the game, and the `update()` method contains the meat of manipulating an entity through various properties. Due to the behavior of the `update()` method, we create methods such as `init()` which will initialize the variables and properties needed by the entity, such as flags denoting when to attack or when to follow a player. 

#### Enemy Artificial Intelligence

Now that we are more familiar with ImpactJS's game loop, we can move on to creating some new enemies. Suppose we want to create a simple entity which will walk from right to left, and if it collides with a wall, it flips and begins to walk in the opposite direction. This is simple enough, as shown in the snippet below of `blue_koopa.js`:

{% highlight javascript linenos %}
/*
    Blue Koopa
    ----------
    AI: Moves left and right, detects ledges.
*/

ig.module('game.entities.enemies.blue_koopa')
.requires('game.entities.ai.basic_ai')

.defines(function() {
    EntityBlue_koopa = EntityBasic_ai.extend({

        // Add animation
        animSheet: new ig.AnimationSheet('media/enemies/koopa_blue.png', 32, 32),
        size: {x: 18, y: 29},
        //flip: false,
        //health: 10,
        collide_damage: 2,
        stomp: new ig.Sound('media/sounds/sfx/smw_stomp.*'),

        // Set up animations
        init: function(x, y, settings) {
            this.parent(x, y, settings);
            this.addAnim('crawl', 0.20, [0,1]);
            this.offset.x = 6;
            this.offset.y = 2;
        },

        update: function() {
            // On collision, a flip property is toggled,
            // allowing movement in the opposite direction
            var xdir = this.flip ? -1 : 1;
            this.vel.x = this.speed * xdir;
            this.parent();
        }
    }); // End EntityBlueKoopa
}); // End .defines

{% endhighlight%}

Even though the enemy above is very simplistic, it follows the main recipe for most enemies in Super Mario World - it moves from right to left, and flips on collision. Building on top of this entity, we can create an entity which follows the player once they are in close proximity to each other. Below is a snippet containing the `update()` method of `flying_yellow_koopa`, which exhibits this behavior: 

{% highlight javascript linenos %}
     update: function() {
            var xdir = this.flip ? 1 : -1;
            this.vel.x = this.speed * xdir;
            this.parent();

            if(my_player != null) {
                var target_x = 0;
                var target_y = 0;
                target_x = my_player.pos.x;
                target_y = my_player.pos.y;
                var stalking = false;

                // Player is within enemy's potential detection range but has not detected player yet
                if(!this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_check_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_check_dist.y) {
                    // Player in enemy's line-of-sight --> Begin stalking behavior
                    if((target_x > this.pos.x && this.flip) || (target_x < this.pos.x && !this.flip))
                        this.stalking = true;
                // Enemy has detected player --> Begin stalking behavior; 
                // Extend detection/stalking range
                } else if(this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_chase_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_chase_dist.y) {
                    // Player is behind enemy --> Enemy faces player
                    if((target_x < this.pos.x && this.flip) || (target_x > this.pos.x && !this.flip)) {
                        this.flip = !this.flip;
                        this.anims.crawl.flip.x = !this.flip;
                    }
                // Player stepped outside of detection distance --> Reset behavior (do not stalk)
                } else
                    this.stalking = false;
            }
        }

{% endhighlight %}

After creating over 20+ enemies, it became clear to my group that creating more advanced entities simply revolves around having more and more properties, with each one acting as flags denoting their behavior at different instances of time based on other conditions. In actuality, this is the power of **Object Oriented Programming**, which gives the advantage of building complex structures while building off objects and the properties/attributes used to describe those objects. Within just a few weeks of development, my group became familiar with the ImpactJS Game Engine and we began to move into more complicated gameplay features. 

#### Level / Music Transitions

Moving on to more aesthetic gameplay features, we decided to tackle the problem of having different songs for each level. ImpactJS has its own `sound` class which can be derived from, unfortunately it has no way of playing different songs for different levels without a hacky solution. Fortunately, we were able to come up with a clever solution involving a plugin created for ImpactJS named `director`, which contains a set of helpful methods for creating an array of levels that can be transitioned through using provided methods. By tailoring this plugin and creating a second array containing our songs, we were able to sync up both our `level array` and `music array` and manipulate the game loop to map each song to each level. The following code snippet shows our solution:

{% highlight javascript linenos %}

    ig.module(
    'plugins.director.director'
    )
    .requires(
        'impact.impact'
    )
    .defines(function(){

    ig.Director = ig.Class.extend({
      //Initialize the class with game representing the main game object
      //and levels being an array of level objects.
      //The first level in the array is loaded by default.
      init: function(theGame, initialLevels, initialSongs, musicDir){
        this.game = theGame;
        this.levels = [];
        this.currentLevel = 0;
        this.append(initialLevels);
        
        musicDir = typeof musicDir !== 'undefined' ? musicDir : "";
        initialSongs = typeof initialSongs !== 'undefined' ? initialSongs : [];
        
        for(var i = 0; i < initialSongs.length; i++){
            ig.music.add(musicDir + initialSongs[i] + '.*', i);
        }
        ig.music.loop = true;
        return this.loadLevel(this.currentLevel);
      },

      loadLevel: function(levelNumber){
        //Load a level by its position in this.levels array
        //and set the this.currentLevel to that position.
        this.currentLevel = levelNumber;

        this.game.loadLevel( this.levels[levelNumber] );
        ig.music.play( levelNumber );
        return true;
      },
      
      append: function(levels){
        //Append a single new level or an array of new levels.
        newLevels = [];
        if (typeof(levels) === 'object'){
          if (levels.constructor === (new Array).constructor){
            newLevels = levels;
          }
          else{
            newLevels[0] = levels;
          }
          this.levels = this.levels.concat(newLevels);
          return true;
        }
        else{
          return false;
        }
      },

      nextLevel: function(){
        //Advance to the next level provided we are not at 
        //the end of the array.
        if (this.currentLevel + 1 < this.levels.length){
          ig.music.next();
          return this.loadLevel(this.currentLevel + 1);
        }
        else{
          return false;
        }
      },
{% endhighlight %}

And here is the change needed within `main.js`:

{% highlight javascript linenos %}
    //LevelIndex:   [0------------, 1------------------, 2---------, 3-------------------, 4---------------------, 5--------------, 6-----------------, 7---------------, 8----------, 9-------------, 10----------------, 11------------, 12-----------, 13------------, 14----------------]
    levelVariables: [LevelTutorial, LevelBest_overworld, LevelSnowy, LevelUndergroundsnow, LevelUndergrounddesert, LevelMainlevel1, LevelOutdoorcastle, LevelForestRuins, LevelDesert,  LevelMountain, LevelMaincastle,    LevelBoss1lair, LevelGauntlet, LevelGauntlet2, LevelFinalgauntlet],
    levelMusic:     ['smw_remix',   'map_theme',         'snowman',  'barrel_volcano',     'ryu',                  'maze',          'snake_man',        'tarm_ruins',     'desert',     'dark_world',  'madness_fortress', 'epic_boss',    'wily_castle', 'wily_castle',  'bowser_battle'],

{% endhighlight %}


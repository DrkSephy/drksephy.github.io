---
layout: portfolio_entry
title: Super Mario World Koopa Krisis
image: /img/koopa-krisis/titlescreen.png
---

Super Mario World - Koopa Krisis is a JavaScript remake of Super Mario World, built on top of the ImpactJS Game Engine, purely for educational purposes. The motivation of this project is to create a browser-only version of one of the most iconic games in the history of Nintendo, and to further my knowledge of JavaScript and the ImpactJS framework.

#### Motivation 

As the new leader of CCNY ACM's Game Development group for the Fall 2013 - Spring 2014 year, I decided to experiment with the ImpactJS Game Engine after being exposed to it in Fall 2012. I decided to begin working on a simple platformer game in late July, which soon turned out to be heavily based on Super Mario World. My motivation was to create a skeleton game which others could build on top of, and to produce a well polished game at the end of the Fall 2013 semester. Once our Game Development club meetings started, I assembled a team of 5 others and development began. 

#### Development Roadmap

My team this semester was very enthusiastic about this game, and so I knew that a detailed listing of all tasks needed to be done. After spending a session explaining the game engine, basic JavaScript and how projects are structured using ImpactJS, my group quickly caught on and started to work on their respective tasks. A list of comprehensive tasks are shown below:

* Artificial Intelligence of Enemies
    * Understanding the ImpactJS Game loop 
    * Graphics for Enemies
* Powerup System
    * Various powerups
    * Powerup transitions when getting hit
* Collectible Items
    * Coins
    * Free lives
* Ability to transition between levels
    * Ability to have different songs per level
* Ability to use pipes to transition to levels
* Sloped tile movement
* Level building
    * Asset gathering

I decided to give each member of my team 1-2 different enemies each week to work on, while providing a skeleton file containing the animation frames already set up, as well as detailed descriptions of enemy behavior coupled with videos of demonstration for those not familiar with Super Mario World. In the meantime, I would work on various systems such as the powerups, collectible items, level building and other things critical to the gameplay itself.

#### Understanding the ImpactJS Game Loop

To discuss creating enemy AI, we must first understand ImpactJS's game loop. Any object that can interact within the game's environment is called an `entity`, and therefore creating new enemies is the same as creating a new entity. Each entity has their own base methods which can be extended. To make our codebase modular, we created a base entity named `basic_ai.js` which contains these methods, allowing us to extend from it and have our new entities inherit the properties from `basic_ai.js` and drastically make our codebase more readable. The following is a listing of the important methods found within our `basic_ai.js` module:

{% highlight javascript linenos %}
    
    init: function(x, y, settings) {
            // Init method is used for setting up animations
            // and temporary variables
            this.parent(x, y, settings);

            // Set up animations
            /** Animations should be handled by each enemy. **/
            this.healthTimer = new ig.Timer();
            tempHealth = this.health;
            // Load player object if not in Weltmeister
            if(!ig.global.wm)
                my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
        }
{% endhighlight %}

{% highlight javascript linenos %}
     // handleMovementTrace is mostly for checking collisions
     // against other entities in conjunction with the 
     // `collidesWith method.
     handleMovementTrace: function(res) {
            this.parent(res);

            // If the enemy collides with a wall, make them turn around.
            if(res.collision.x) {
                this.flip = !this.flip;
                this.currentAnim.flip.x = this.flip;
            }
        }, 
    
{% endhighlight%}

{% highlight javascript linenos %}
    // Collisions with player are handled through the following function.
        /** Certain enemies with advanced collisions may wish to override this
            function with their own collision handling code. **/
        collideWith: function(other, axis) {
            // Only do something if colliding with the Player
            if(other instanceof EntityPlayer) {
                // Prevents enemy from being killed from below.
                if(axis == 'y' && this.pos.y > other.pos.y) {
                    other.vel.y = this.damage_jump;
                    this.kill();
                } else {
                    other.receiveDamage(this.collide_damage, this);
                    // Push player back if collides with enemy horizontally.
                    if(other.pos.x > this.pos.x)
                        other.vel.x = this.damage_push;
                    else
                        other.vel.x = -this.damage_push;
                }
                
                // If player's health <= 0 (player dead), re-detect player
                // entity (respawned player).
                if(other.health <= 0)
                    my_player = ig.game.getEntitiesByType('EntityPlayer')[0];
            }
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Simply setting up collisions isn't enough, we must create a method
    // which will check if a collision occurs. This method overrides the
    // .check() function, which gets called when a collision is detected,
    // and applies damage to the entity it collides with.
    check: function(other, axis) {
            if(other instanceof EntityPlayer)
                if(axis == 'x')
                    other.receiveDamage(this.collide_damage, this);
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy's death (and player's rewards from enemy's death) is handled
    // through the following function.
        kill: function() {
            ig.game.stats.kills++;
            ig.game.increaseScore(this.kill_score);
            ig.game.spawnEntity(EntityDeathExplosionParticle, this.pos.x, this.pos.y, {particles:2, colorOffset: 1});
            this.parent();
        },
{% endhighlight %}

{% highlight javascript linenos %}
    // Enemy receiving damage is handled through the following function.
        receiveDamage: function(value) {
            this.parent(value);
            this.healthTimer.set(0);
        }
{% endhighlight %}

With these methods written, there only remains two methods needed to implement: `draw()` and `update()`. Both of these methods are called on every frame of the game, and the `update()` method contains the meat of manipulating an entity through various properties. Due to the behavior of the `update()` method, we create methods such as `init()` which will initialize the variables and properties needed by the entity, such as flags denoting when to attack or when to follow a player. 

#### Enemy Artificial Intelligence

Now that we are more familiar with ImpactJS's game loop, we can move on to creating some new enemies. Suppose we want to create a simple entity which will walk from right to left, and if it collides with a wall, it flips and begins to walk in the opposite direction. This is simple enough, as shown in the snippet below of `blue_koopa.js`:

{% highlight javascript linenos %}
/*
    Blue Koopa
    ----------
    AI: Moves left and right, detects ledges.
*/

ig.module('game.entities.enemies.blue_koopa')
.requires('game.entities.ai.basic_ai')

.defines(function() {
    EntityBlue_koopa = EntityBasic_ai.extend({

        // Add animation
        animSheet: new ig.AnimationSheet('media/enemies/koopa_blue.png', 32, 32),
        size: {x: 18, y: 29},
        //flip: false,
        //health: 10,
        collide_damage: 2,
        stomp: new ig.Sound('media/sounds/sfx/smw_stomp.*'),

        // Set up animations
        init: function(x, y, settings) {
            this.parent(x, y, settings);
            this.addAnim('crawl', 0.20, [0,1]);
            this.offset.x = 6;
            this.offset.y = 2;
        },

        update: function() {
            // On collision, a flip property is toggled,
            // allowing movement in the opposite direction
            var xdir = this.flip ? -1 : 1;
            this.vel.x = this.speed * xdir;
            this.parent();
        }
    }); // End EntityBlueKoopa
}); // End .defines

{% endhighlight%}

Even though the enemy above is very simplistic, it follows the main recipe for most enemies in Super Mario World - it moves from right to left, and flips on collision. Building on top of this entity, we can create an entity which follows the player once they are in close proximity to each other. Below is a snippet containing the `update()` method of `flying_yellow_koopa`, which exhibits this behavior: 

{% highlight javascript linenos %}
     update: function() {
            var xdir = this.flip ? 1 : -1;
            this.vel.x = this.speed * xdir;
            this.parent();

            if(my_player != null) {
                var target_x = 0;
                var target_y = 0;
                target_x = my_player.pos.x;
                target_y = my_player.pos.y;
                var stalking = false;

                // Player is within enemy's potential detection range but has not detected player yet
                if(!this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_check_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_check_dist.y) {
                    // Player in enemy's line-of-sight --> Begin stalking behavior
                    if((target_x > this.pos.x && this.flip) || (target_x < this.pos.x && !this.flip))
                        this.stalking = true;
                // Enemy has detected player --> Begin stalking behavior; 
                // Extend detection/stalking range
                } else if(this.stalking && Math.abs(target_x - this.pos.x) <= this.stalk_chase_dist.x && Math.abs(target_y - this.pos.y) <= this.stalk_chase_dist.y) {
                    // Player is behind enemy --> Enemy faces player
                    if((target_x < this.pos.x && this.flip) || (target_x > this.pos.x && !this.flip)) {
                        this.flip = !this.flip;
                        this.anims.crawl.flip.x = !this.flip;
                    }
                // Player stepped outside of detection distance --> Reset behavior (do not stalk)
                } else
                    this.stalking = false;
            }
        }

{% endhighlight %}

After creating over 20+ enemies, it became clear to my group that creating more advanced entities simply revolves around having more and more properties, with each one acting as flags denoting their behavior at different instances of time based on other conditions. In actuality, this is the power of **Object Oriented Programming**, which gives the advantage of building complex structures while building off objects and the properties/attributes used to describe those objects. Within just a few weeks of development, my group became familiar with the ImpactJS Game Engine and we began to move into more complicated gameplay features. 

#### Level / Music Transitions

Moving on to more aesthetic gameplay features, we decided to tackle the problem of having different songs for each level. ImpactJS has its own `sound` class which can be derived from, unfortunately it has no way of playing different songs for different levels without a hacky solution. Fortunately, we were able to come up with a clever solution involving a plugin created for ImpactJS named `director`, which contains a set of helpful methods for creating an array of levels that can be transitioned through using provided methods. By tailoring this plugin and creating a second array containing our songs, we were able to sync up both our `level array` and `music array` and manipulate the game loop to map each song to each level. The following code snippet shows our solution:

{% highlight javascript linenos %}

    ig.module(
    'plugins.director.director'
    )
    .requires(
        'impact.impact'
    )
    .defines(function(){

    ig.Director = ig.Class.extend({
      //Initialize the class with game representing the main game object
      //and levels being an array of level objects.
      //The first level in the array is loaded by default.
      init: function(theGame, initialLevels, initialSongs, musicDir){
        this.game = theGame;
        this.levels = [];
        this.currentLevel = 0;
        this.append(initialLevels);
        
        musicDir = typeof musicDir !== 'undefined' ? musicDir : "";
        initialSongs = typeof initialSongs !== 'undefined' ? initialSongs : [];
        
        for(var i = 0; i < initialSongs.length; i++){
            ig.music.add(musicDir + initialSongs[i] + '.*', i);
        }
        ig.music.loop = true;
        return this.loadLevel(this.currentLevel);
      },

      loadLevel: function(levelNumber){
        //Load a level by its position in this.levels array
        //and set the this.currentLevel to that position.
        this.currentLevel = levelNumber;

        this.game.loadLevel( this.levels[levelNumber] );
        ig.music.play( levelNumber );
        return true;
      },
      
      append: function(levels){
        //Append a single new level or an array of new levels.
        newLevels = [];
        if (typeof(levels) === 'object'){
          if (levels.constructor === (new Array).constructor){
            newLevels = levels;
          }
          else{
            newLevels[0] = levels;
          }
          this.levels = this.levels.concat(newLevels);
          return true;
        }
        else{
          return false;
        }
      },

      nextLevel: function(){
        //Advance to the next level provided we are not at 
        //the end of the array.
        if (this.currentLevel + 1 < this.levels.length){
          ig.music.next();
          return this.loadLevel(this.currentLevel + 1);
        }
        else{
          return false;
        }
      },
{% endhighlight %}

And here is the change needed within `main.js`:

{% highlight javascript linenos %}
    //LevelIndex:   [0------------, 1------------------, 2---------, 3-------------------, 4---------------------, 5--------------, 6-----------------, 7---------------, 8----------, 9-------------, 10----------------, 11------------, 12-----------, 13------------, 14----------------]
    levelVariables: [LevelTutorial, LevelBest_overworld, LevelSnowy, LevelUndergroundsnow, LevelUndergrounddesert, LevelMainlevel1, LevelOutdoorcastle, LevelForestRuins, LevelDesert,  LevelMountain, LevelMaincastle,    LevelBoss1lair, LevelGauntlet, LevelGauntlet2, LevelFinalgauntlet],
    levelMusic:     ['smw_remix',   'map_theme',         'snowman',  'barrel_volcano',     'ryu',                  'maze',          'snake_man',        'tarm_ruins',     'desert',     'dark_world',  'madness_fortress', 'epic_boss',    'wily_castle', 'wily_castle',  'bowser_battle'],

{% endhighlight %}

After understanding how `director.js` works in conjunction with the ImpactJS game loop, we moved onto something new: transitioning between different levels / different parts within the same level using warp pipes/doors.

#### Transitioning to Different Parts within a Level

Based on the properties of `director.js`, we realized that we can extend director and apply it to creating a `pipe` entity, which can take an arbitrary `key:value` pair representing the position/level to warp the `player.js` entity to. The following is the `check()` method for the `pipe.js` entity:

{% highlight javascript linenos %}
    update: function() {this.parent();},

        // Handle player transitions to different levels
        check: function(other) {
            // Entity is on pipe but not using it
            if(other.pos.y <= this.pos.y - other.size.y + 4 && !this.usingPipe) {
                other.pos.y = this.pos.y - other.size.y;
                // Entity is player; handles player animations (If entity is not player ignore entity)
                if(other instanceof EntityPlayer) {
                    this.onPipe = true;
                    // Handle player's movements while on pipe
                    if(ig.input.state('left') || ig.input.state('right')) {
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_run;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_run;
                        else
                            other.currentAnim = other.anims.run;
                    } else if(ig.input.state('jump')) {
                        other.vel.y = -other.jump;
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_jump;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_jump;
                        else
                            other.currentAnim = other.anims.jump;
                    } else {
                        if(ig.main.activePower == "EntityHammer")
                            other.currentAnim = other.anims.hammer_idle;
                        else if(ig.main.activePower == "EntityFireball")
                            other.currentAnim = other.anims.fire_idle;
                        else
                            other.currentAnim = other.anims.idle;
                    }

                    // Player uses pipe and is standing within acceptable boundaries of pipe
                    if(ig.input.state('continue') && this.onPipe && other.pos.x > this.pos.x && other.pos.x < this.pos.x + other.size.x) {
                        // Reposition player to center of pipe
                        other.pos.x = this.pos.x + this.size.x/2 - other.size.x/2;
                        // Start pipe usage
                        this.usingPipe = true;
                    }
                }
            // Entiy not on pipe
            } else if(!this.usingPipe) {
                // Entity is player; handle player-specific repositioning ("fake collision")
                if(other instanceof EntityGameplayer) {
                    this.onPipe = false;
                    if(other.pos.x <= this.pos.x)
                        other.pos.x = this.pos.x - other.size.x;
                    else
                        other.pos.x = this.pos.x + this.size.x;
                // Entity is not player; handle other entity's repositioning
                } else {
                    other.flip = !other.flip;
                    other.currentAnim.flip.x = other.flip;
                }
            // Player is using pipe
            } else {
                // Play some player "using pipe" animation and begin to descend player down pipe
                if(ig.main.activePower == "EntityHammer")
                    other.currentAnim = other.anims.hammer_idle;
                else if(ig.main.activePower == "EntityFireball")
                    other.currentAnim = other.anims.fire_idle;
                else
                    other.currentAnim = other.anims.idle;
                other.vel.y = this.pipeSpeed;
                // If player is using pipe, make sure player STAYS IN THE PIPE!
                other.pos.x = this.pos.x + this.size.x/2 - other.size.x/2;
                // Player is completely inside pipe
                if(other.pos.y > this.pos.y) {
                    // Handle level transitioning
                    // Level property has been set in Weltmeister
                    if(this.level !== null && this.level >= 0) {
                        // Transition to specified level
                        ig.game.myDirector.loadLevel(this.level);
                    // Level property has NOT been set in Weltmeister
                    } else if(this.level === null) {
                        // Transition to next level
                        ig.game.myDirector.nextLevel();
                    }

                    // Spawn position has been set in Weltmeister
                    if(this.spawn.x !== null && this.spawn.y !== null) {
                        // Move player to specified (x, y) position of new level
                        my_player.pos.x = this.spawn.x;
                        my_player.pos.y = this.spawn.y;
                    }
                }
            }

{% endhighlight %}

With this, we were able to use pipes to transition to bonus levels or to go to different portions within a level (as well as return), just like the original Super Mario World!

#### Overworld

As one last aesthetic feature, we decided to tackle creating an overworld. The first task was to figure out how to transition between different game states within ImpactJS, while still having a reference to levels and the player entity without making these global variables. Due to having a top-down perspective for the overworld (as opposed to side-scrolling in the main game), a different player entity was necessary to be used on the overworld (along with its own set of physics and properties). This proved to be a major task due to confusion of how `director.js` worked in tandem with ImpactJS's `loadLevel()` method. After roughly 45 days of working on a solution, we tailored `director.js` further (the changes were included in the listing provided earlier) and made the following changes to `main.js`:

{% highlight javascript linenos %}
    update: function() {
        /* This code allows the camera to follow the player
           by overriding the update function using the method
           of the game class called `getEntitiesByType()`.
           This API allows us to find instances of entities in
           our game. */

        var player = this.getEntitiesByType( EntityPlayer )[0];
        if( player ) {
            this.camera.follow(this.player);
            //this.screen.x = player.pos.x - ig.system.width/2;
            //this.screen.y = player.pos.y - ig.system.height/2;
            // If the player moves, erase the instructions
            if(player.accel.x > 0 && this.font)
                this.font = null;
        }
        // Update all entities and backgroundMaps
        /* We need to change this code to pull up the stat screen.
           We test if it is time to show the stats screen. If it
           is not being displayed, we call "this.parent()" and the
           game continues normally. Otherwise, we listen for an input
           state 'continue' */
        if(!this.showStats && !this.showEnding){
            this.parent();
        } else {
            if(ig.input.pressed('continue')) {
                this.parent();
                if(this.myDirector.currentLevel !== this.finalStage || this.finalStageEnabled) {
                    this.showEnding = false;
                    this.showStats = false;
                    this.maxStage = this.myDirector.currentLevel;
                    this.myDirector.loadLevel(1);
                    ig.music.play(1);
                } else {
                    this.showEnding = false;
                    this.showStats = false;
                    if(this.lives < this.bonusReqLives || this.finalStageEnabled) {
                        ig.system.setGame(StartScreen);
                    } else {
                        this.finalStageEnabled = true;
                        this.maxStage = this.myDirector.currentLevel;
                        this.myDirector.loadLevel(1);
                        ig.music.play(1);
                    }
                }
            }
        }
{% endhighlight %}

After having the ability to transition between different game states while swapping out different entities based on the level, a custom overworld was built from scratch:

![Koopa Krisis Overworld]({{ site.url }}/img/koopa-krisis/overworld.png)


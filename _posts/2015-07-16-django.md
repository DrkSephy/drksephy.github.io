---
layout: post
title: Django tutorial
subtitle: "Build a Django application from scratch using the Github RESTful API, front-end package dependency managers such as Bower."
date: 2015-07-16
tags: [Tutorial]
author: "David Leonard"
header-img: "img/tracks.jpg"
---

Django is a popular Python web framework which gives developers the power to develop their own web applications. In this tutorial, we will be building a Django application from the ground up which will allow the user to query Github data through the use of a form. We'll be covering the following topics:

* Starting a Django Application
* Project structure breakdown
* Configuring a proper development environment
* Python Requests library
* MVC (Models - Views - Contollers)
* Querying an API using Python Requests library
* JSON (JavaScript Object Notation)

If you aren't familiar with these topics, don't sweat it. We'll cover these topics in detail which will get you up to speed in no time. 

### Models, Views, Controllers 

The core structure of any web framework can be broken into three parts: the Models, Views, and Controllers. This pattern allows developers to have a separation of concerns when building an application, and allows us to impose a logical structure to our projects. Let's go over these parts in more detail. 

#### Models

Within a web framework, **Models** are your data layer. At any given time, your models will represent what your objects in your database will look like. For example, take a look at the following Django model shown below:

Sample model
Description of Model

But how do we store these models in our database? Simple enough, Django provides abstractions for turning our models into database entries with the use of a few simple commands:

Database commands
Database command explanations

Under the hood, Django is using these models to programmatically return SQL, which in turn will store these models into a SQL database (MySQL, SQLite3, PostgreSQL). Using these methods, we won't have to write our own database logic using SQL. 


#### Views

Views generally consist of a combination of templates and a URL dispatcher. In Django, we are provided with the ability to write templates (which are essentially HTML files) coupled with template variables which will get passed in through our controller. 


#### Controllers

Controllers have one main purpose: to operate on our data layer and return this data to our templates, which will generate HTML content to the user. In Django, we typically write our controllers within a `views.py` file. 

With this terminology out of the way, let's talk about general application flow in a given Django application.


#### Application Flow

The behavior of any Django Application (or web frameworks, in general) can be broken down as follows:

1. The user visits a URL, such as `/amazon/games`
2. This triggers a request to that URL, which is looked up in our URL dispatcher
3. The URL dispatcher will map this URL to a function within our Views
4. The View function will then access models, perform queries or fetch data as needed, which is bundled up and passed into a template
5. The data passed into the template is then emitted to the user

By following this flow, it becomes easier to reason about our applications even when they begin to grow larger and larger.

In this application, we won't be making extensive use of Models. Instead, we'll be building out a sample URL which the user can visit to query their public user information on Github using their RESTful API. Once this initial task is done, we'll refactor our code and provide a form in which the user can enter in a username of anyone on Github and display their information through a template. 

With that all said and done, let's get into the development of the application.


#### Starting our application

To kick things off, let's create our Django project. Within your terminal:

{% highlight bash %}
	django-admin startproject demonstration
{% endhighlight %}

Where **demonstration** is the name you choose for your own project. 

<blockquote><b>Tip:</b> Avoid using names such as django or test, these names will collide with built-in Python packages.</blockquote>






